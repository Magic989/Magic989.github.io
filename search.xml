<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2.1.3.3-结构体使用及产品应用</title>
      <link href="/posts/e47a3aac.html"/>
      <url>/posts/e47a3aac.html</url>
      
        <content type="html"><![CDATA[<ol><li>掌握结构体的概念和用法</li><li>掌握结构体数组和结构体指针</li><li>掌握结构体的结构体</li><li>掌握结构体搭建链表的方法</li><li>掌握结构体及链表在产品上的应用</li></ol><p>一般的数据类型只能构造同一个类型的数据，但是在不同情况下，我们需要将不同的数据类型组合成一种新的数据结构，比如说像学生的信息包含学生姓名、学号、性别、年龄等信息。那么这些参数里可能有些是数组型、字符型、整型甚至是结构体类型的数据，基于这种需求，结构体就诞生了。结构体就是所谓“面向对象”的编程思想，将某个物体视为一个对象，把这个对象的特性封装在结构体中，用到哪个特性就将其从对象中提取出来。</p><h2 id="定义语法"><a class="markdownIt-Anchor" href="#定义语法"></a> 定义语法</h2><p>结构体有以下两种定义方式，在中大型产品中往往使用typedef版本，因为这样可以大大提高代码可读性。</p><h3 id="标准语法"><a class="markdownIt-Anchor" href="#标准语法"></a> 标准语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> year;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mon;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Date</span> Today;</span><br><span class="line">    Today.year = <span class="number">2023</span>;</span><br><span class="line">    Today.mon = <span class="number">5</span>;</span><br><span class="line">    Today.day = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d-%d-%d&quot;</span>,Today.year,Today.mon,Today.day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typedef版语法"><a class="markdownIt-Anchor" href="#typedef版语法"></a> typedef版语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> year;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mon;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> day;</span><br><span class="line">&#125;Date;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date Today;</span><br><span class="line">    Today.year = <span class="number">2023</span>;</span><br><span class="line">    Today.mon = <span class="number">5</span>;</span><br><span class="line">    Today.day = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d-%d-%d&quot;</span>,Today.year,Today.mon,Today.day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体数组"><a class="markdownIt-Anchor" href="#结构体数组"></a> 结构体数组</h2><p>当我们要定义10个整型变量时，我们可以通过定义成数组的方式。结构体自然也能定义成数组的方式，比如要定义3个不同日期数据时，就会用到结构体数组。<br />有好几种定义方法，但有两种最为常用。</p><h3 id="直接用struct声明结构体"><a class="markdownIt-Anchor" href="#直接用struct声明结构体"></a> 直接用struct声明结构体</h3><p>直接用struct声明一个结构体，然后再定义结构体数组，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名称 数组名[数组大小]</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  structArray.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> year;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mon;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Date</span> date[<span class="number">3</span>] = &#123;&#123;<span class="number">2023</span>,<span class="number">5</span>,<span class="number">17</span>&#125;,&#123;<span class="number">2023</span>,<span class="number">5</span>,<span class="number">18</span>&#125;,&#123;<span class="number">2023</span>,<span class="number">5</span>,<span class="number">19</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">short</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-%d-%d\r\n&quot;</span>,date[i].year,date[i].mon,date[i].day);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用typedef-struct声明结构体"><a class="markdownIt-Anchor" href="#用typedef-struct声明结构体"></a> 用typedef struct声明结构体</h3><p>用typedef struct声明一个结构体，并且为结构体重命名，通过重命名的方式定义结构体数组。定义格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构体重命名 数组名[数组大小]</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> year;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mon;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> day;</span><br><span class="line">&#125;Date;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date date[<span class="number">3</span>] = &#123;&#123;<span class="number">2023</span>,<span class="number">5</span>,<span class="number">17</span>&#125;,&#123;<span class="number">2023</span>,<span class="number">5</span>,<span class="number">18</span>&#125;,&#123;<span class="number">2023</span>,<span class="number">5</span>,<span class="number">19</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">short</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-%d-%d\r\n&quot;</span>,date[i].year,date[i].mon,date[i].day);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包含结构体的结构体"><a class="markdownIt-Anchor" href="#包含结构体的结构体"></a> 包含结构体的结构体</h2><p>结构体的成员不仅可以是字符型、整型、数组型数据类型，也可以是结构体。<br />例如存放学生信息的结构体包括姓名、学号性别、出生日期等数据，而出生日期又包含年月日这3个成员，所以出生日期可以单独声明一个结构体，学生这个结构体包含出生日期这个结构体，这种就是包含结构体的结构体，如下图所示。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.1.3.3/%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E7%BB%93%E6%9E%84%E4%BD%93.webp" alt="P3.1-学生信息结构体.webp" /></p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// structOfStruct.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> year;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> mon;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> day;</span><br><span class="line">&#125;Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> number;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    Date birth;</span><br><span class="line">&#125;student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    student stu1 = &#123;<span class="string">&quot;xiaowang&quot;</span>, <span class="number">1</span>, <span class="string">&#x27;m&#x27;</span>, &#123;<span class="number">1996</span>, <span class="number">7</span>, <span class="number">5</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name:\t\t%s\r\nnumber:\t\t%d\r\nsex:\t\t%c\r\nbirthday:\t%d-%d-%d\r\n&quot;</span>,</span><br><span class="line">        stu1.name, stu1.number, stu1.sex, stu1.birth.year,stu1.birth.mon,stu1.birth.day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h2><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.1.3.3/%E9%93%BE%E8%A1%A8%E5%8E%9F%E7%90%86.webp" alt="P4.1-链表原理.webp" /></p><p>在结构体内定义结构体指针，使这个指针指向链表的下一项，从而利用头指针读取所有结构体的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linkedList.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> number;</span><br><span class="line">    student *pLast;</span><br><span class="line">    student *pNext;</span><br><span class="line">&#125;student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    student *pStu;</span><br><span class="line">    student stu[<span class="number">4</span>] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;stu1&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;stu2&quot;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;stu3&quot;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;stu4&quot;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) stu[i].pNext = &amp;stu[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">4</span>; i &gt; <span class="number">1</span>; i--) stu[i].pLast = &amp;stu[i<span class="number">-1</span>];   <span class="comment">//双向链表</span></span><br><span class="line">    pStu = &amp;stu[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name:%s, sex:%c, number:%d\r\n&quot;</span>,pStu-&gt;name,pStu-&gt;sex,pStu-&gt;number);</span><br><span class="line">        pStu = pStu-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的结构体声明前后都有student。去掉上一个会直接报错，因为结构体内部也用到了student这个结构体；去掉下面那个可以运行但会提示 ‘typedef’ was ignored in this declaration，因为此时结构体没有使用别名，但MinGW的编译器是可以正常编译程序的。</p><p>如果要使用双向链表，则需要对每一个对象中的pLast赋值。</p><h2 id="结构体和链表的实际应用"><a class="markdownIt-Anchor" href="#结构体和链表的实际应用"></a> 结构体和链表的实际应用</h2><p>链表是基于结构体的一种线性的数据结构。<br />凡是有多种属性的对象，都可以用结构体来构造。比如说单片机的串口有时钟源、波特率、停止位、校验位等等属性，那么就可以用结构体构造单片机串口对象。<br />链表分为静态链表和动态链表。<br /><font color=red>静态链表</font>适用于一些固定数量的数据结构。比如多级菜单，用屏幕显示多级菜单时都会用按键或者触摸进入子菜单或者返回主菜单，此时就可以把这些主菜单和子菜单做成一个链表，配合结构体指针就能轻松灵活地找到需要跳转的菜单。<br /><font color=red>动态链表</font>适用于底层操作系统，在不知道串口到底会来多少数据的情况下，使用数组很有可能造成内存浪费，或者数组位数不足。动态链表在接收消息队列和任务创建方面有着得天独厚的优势。</p>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.1. C语言基础 </category>
          
          <category> 2.1.3. 程序架构内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 程序架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.3.2-指针基础及产品应用</title>
      <link href="/posts/f47db864.html"/>
      <url>/posts/f47db864.html</url>
      
        <content type="html"><![CDATA[<p>使用指针可以分离硬件层驱动程序(GPIO、串口、定时器)和应用层程序，达到程序分离、提高程序可移植性的目的，但是容易出bug。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pointer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;  </span><br><span class="line">    <span class="type">int</span> *p; <span class="comment">//将int*视为一个关键字来理解，这个关键字是为了创建指向int类型数据的指针地址</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;//-----------------变量a地址-------------------//\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a=0x%x\r\n&quot;</span>,&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p=0x%x\r\n&quot;</span>,p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p=0x%x\r\n\r\n&quot;</span>,&amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;//----------------变量a的值--------------------//\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\r\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\r\n\r\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;//----------通过指针变量改变a的值---------------//\r\n&quot;</span>);</span><br><span class="line">    *p = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\r\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\r\n\r\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;//-----通过a的内存地址改变a的值（每次的地址不同）---------------//\r\n&quot;</span>);</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">int</span>*)(<span class="number">0x61fe1c</span>) = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d\r\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p=%d\r\n\r\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>或者可以将 *p 理解为一个变量，只有当 *p 和 a 的数据类型相同时，p 中才可以存放  &amp;a。</p></blockquote><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ .\Pointer.exe</span><br><span class="line">//-----------------变量a地址-------------------//</span><br><span class="line">&amp;a=0x61fe1c</span><br><span class="line">p=0x61fe1c</span><br><span class="line">&amp;p=0x61fe10</span><br><span class="line"></span><br><span class="line">//----------------变量a的值--------------------//</span><br><span class="line">a=10</span><br><span class="line">*p=10</span><br><span class="line"></span><br><span class="line">//----------通过指针变量改变a的值---------------//</span><br><span class="line">a=11</span><br><span class="line">*p=11</span><br><span class="line"></span><br><span class="line">//-----通过a的内存地址改变a的值（每次的地址不同）---------------//</span><br><span class="line">a=12</span><br><span class="line">*p=12</span><br></pre></td></tr></table></figure><h2 id="数组与指针"><a class="markdownIt-Anchor" href="#数组与指针"></a> 数组与指针</h2><p>编译器会分配连续地址的内存来存储数组里的元素，如果把数组地址赋值给指针变量，那么就可以通过指针变量读写数组中的元素。<br />以下有两种方法，均可将数组buff地址赋值给指针变量p1,p2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array_and_pointer_define.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> buff[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p1,*p2;</span><br><span class="line">    p1 = buff;          <span class="comment">// 赋值方法1</span></span><br><span class="line">    p2 = &amp;buff[<span class="number">0</span>];      <span class="comment">// 赋值方法2</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buff = 0x%x\r\n&quot;</span>,buff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;buff = 0x%x\r\n&quot;</span>,&amp;buff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1_addr = 0x%x\r\n&quot;</span>,p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2_addr = 0x%x\r\n\r\n&quot;</span>,p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buff[0] = %d\r\n&quot;</span>,buff[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p1 = %d\r\n&quot;</span>,*p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p2 = %d\r\n&quot;</span>,*p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ .\array_and_pointer_define.exe</span><br><span class="line">buff = 0x61fdf0</span><br><span class="line">&amp;buff = 0x61fdf0</span><br><span class="line">p1_addr = 0x61fdf0</span><br><span class="line">p2_addr = 0x61fdf0</span><br><span class="line"></span><br><span class="line">buff[0] = 1</span><br><span class="line">*p1 = 1</span><br><span class="line">*p2 = 1</span><br></pre></td></tr></table></figure><h2 id="指针的自加减运算"><a class="markdownIt-Anchor" href="#指针的自加减运算"></a> 指针的自加减运算</h2><p>指针变量除了可以获取内存地址的值，还可以用来进行加减运算，此时加减的是地址。<br />指针变量的类型也会影响自加减运算后指针所存储的地址的值。</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array_and_pointer_++or--.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buff[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">    p = &amp;buff[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;buff[0] = 0x%x buff[0] = %d\r\n&quot;</span>,&amp;buff[<span class="number">0</span>],buff[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;buff[1] = 0x%x buff[1] = %d\r\n&quot;</span>,&amp;buff[<span class="number">1</span>],buff[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;buff[2] = 0x%x buff[2] = %d\r\n&quot;</span>,&amp;buff[<span class="number">2</span>],buff[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;buff[3] = 0x%x buff[3] = %d\r\n&quot;</span>,&amp;buff[<span class="number">3</span>],buff[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;buff[4] = 0x%x buff[4] = %d\r\n\r\n&quot;</span>,&amp;buff[<span class="number">4</span>],buff[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x    *p = %d    &amp;p = 0x%x\r\n&quot;</span>,p,*p,&amp;p);p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x    *p = %d    &amp;p = 0x%x\r\n&quot;</span>,p,*p,&amp;p);p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x    *p = %d    &amp;p = 0x%x\r\n&quot;</span>,p,*p,&amp;p);p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x    *p = %d    &amp;p = 0x%x\r\n&quot;</span>,p,*p,&amp;p);p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x    *p = %d    &amp;p = 0x%x\r\n&quot;</span>,p,*p,&amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ .\array_and_pointer_++or--.exe</span><br><span class="line">&amp;buff[0] = 0x61fe1b buff[0] = 1</span><br><span class="line">&amp;buff[1] = 0x61fe1c buff[1] = 2</span><br><span class="line">&amp;buff[2] = 0x61fe1d buff[2] = 3</span><br><span class="line">&amp;buff[3] = 0x61fe1e buff[3] = 4</span><br><span class="line">&amp;buff[4] = 0x61fe1f buff[4] = 5</span><br><span class="line"></span><br><span class="line">p = 0x61fe1b    *p = 1    &amp;p = 0x61fe10</span><br><span class="line">p = 0x61fe1c    *p = 2    &amp;p = 0x61fe10</span><br><span class="line">p = 0x61fe1d    *p = 3    &amp;p = 0x61fe10</span><br><span class="line">p = 0x61fe1e    *p = 4    &amp;p = 0x61fe10</span><br><span class="line">p = 0x61fe1f    *p = 5    &amp;p = 0x61fe10</span><br></pre></td></tr></table></figure><p>此时p<ins>使得指针地址偏移1byte，因为unsigned char类型占据1byte的内存空间；假如指针变量指向值的数据类型为int，p</ins>会使指针地址偏移4byte，因为int类型占据4byte的内存空间。</p><h2 id="二维数组与指针"><a class="markdownIt-Anchor" href="#二维数组与指针"></a> 二维数组与指针</h2><p>对于二维数组，不能直接以&quot;p = buff&quot;赋值，必须使用以下格式赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;buff[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>二维数组与指针的操作也是一样的，都是分配连续地址存储数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//two-dimensionalArrayPointer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buff[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">    p = &amp;buff[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;buff[0][0] = 0x%x  buff[0][0] = %d\r\n&quot;</span>,&amp;buff[<span class="number">0</span>][<span class="number">0</span>],buff[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;buff[0][1] = 0x%x  buff[0][1] = %d\r\n&quot;</span>,&amp;buff[<span class="number">0</span>][<span class="number">1</span>],buff[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;buff[0][2] = 0x%x  buff[0][2] = %d\r\n&quot;</span>,&amp;buff[<span class="number">0</span>][<span class="number">2</span>],buff[<span class="number">0</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;buff[1][0] = 0x%x  buff[1][0] = %d\r\n&quot;</span>,&amp;buff[<span class="number">1</span>][<span class="number">0</span>],buff[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;buff[1][1] = 0x%x  buff[1][1] = %d\r\n&quot;</span>,&amp;buff[<span class="number">1</span>][<span class="number">1</span>],buff[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;buff[1][2] = 0x%x  buff[1][2] = %d\r\n\r\n&quot;</span>,&amp;buff[<span class="number">1</span>][<span class="number">2</span>],buff[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x    *p = %d    &amp;p = 0x%x\r\n&quot;</span>,p,*p,&amp;p);p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x    *p = %d    &amp;p = 0x%x\r\n&quot;</span>,p,*p,&amp;p);p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x    *p = %d    &amp;p = 0x%x\r\n&quot;</span>,p,*p,&amp;p);p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x    *p = %d    &amp;p = 0x%x\r\n&quot;</span>,p,*p,&amp;p);p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x    *p = %d    &amp;p = 0x%x\r\n&quot;</span>,p,*p,&amp;p);p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p = 0x%x    *p = %d    &amp;p = 0x%x\r\n&quot;</span>,p,*p,&amp;p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ .\two-dimensionalArrayPointer.exe</span><br><span class="line">&amp;buff[0][0] = 0x61fe1a  buff[0][0] = 1</span><br><span class="line">&amp;buff[0][1] = 0x61fe1b  buff[0][1] = 2</span><br><span class="line">&amp;buff[0][2] = 0x61fe1c  buff[0][2] = 3</span><br><span class="line">&amp;buff[1][0] = 0x61fe1d  buff[1][0] = 4</span><br><span class="line">&amp;buff[1][1] = 0x61fe1e  buff[1][1] = 5</span><br><span class="line">&amp;buff[1][2] = 0x61fe1f  buff[1][2] = 6</span><br><span class="line"></span><br><span class="line">p = 0x61fe1a    *p = 1    &amp;p = 0x61fe10</span><br><span class="line">p = 0x61fe1b    *p = 2    &amp;p = 0x61fe10</span><br><span class="line">p = 0x61fe1c    *p = 3    &amp;p = 0x61fe10</span><br><span class="line">p = 0x61fe1d    *p = 4    &amp;p = 0x61fe10</span><br><span class="line">p = 0x61fe1e    *p = 5    &amp;p = 0x61fe10</span><br><span class="line">p = 0x61fe1f    *p = 6    &amp;p = 0x61fe10</span><br></pre></td></tr></table></figure><h2 id="指向指针变量所属地址的指针双重指针"><a class="markdownIt-Anchor" href="#指向指针变量所属地址的指针双重指针"></a> 指向指针变量所属地址的指针（双重指针）</h2><p>指针变量可以指向整型变量或字符型变量，当然也可以指向指针变量的存储地址，简称为双重指针。<br />例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// double_pointer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> **p2;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    p1 = &amp;a;</span><br><span class="line">    p2 = &amp;p1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = 0x%x   a = %d\r\n&quot;</span>,&amp;a,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p1 = 0x%x   p1 = 0x%x\r\n&quot;</span>,&amp;p1,p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p2 = 0x%x   p2 = 0x%x\r\n&quot;</span>,&amp;p2,p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p1 = %d\r\n&quot;</span>,*p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p2 = 0x%x\r\n&quot;</span>,*p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**p1 = %d\r\n&quot;</span>,**p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ .\double_pointer.exe</span><br><span class="line">&amp;a = 0x61fe1f   a = 10</span><br><span class="line">&amp;p1 = 0x61fe10   p1 = 0x61fe1f</span><br><span class="line">&amp;p2 = 0x61fe08   p2 = 0x61fe10</span><br><span class="line">*p1 = 10</span><br><span class="line">*p2 = 0x61fe1f</span><br><span class="line">**p1 = 10</span><br></pre></td></tr></table></figure><h2 id="指针变量作为函数形参"><a class="markdownIt-Anchor" href="#指针变量作为函数形参"></a> 指针变量作为函数形参</h2><p>一般情况下以字符型、整型、数组等作为函数的形参输入，指针也能作为函数的形参输入，主要目的是改变指针指向地址的值，专业术语是通过形参改变实参的值。（起到参数传递的作用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pointer_parameter.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SetValue</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = <span class="number">20</span>;    <span class="comment">//将20赋值给形参所指向的的地址位</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SetValue</span>(&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\r\n&quot;</span>,a);  <span class="comment">//起到传递参数的作用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ .\pointer_parameter.exe</span><br><span class="line">a = 20</span><br></pre></td></tr></table></figure><h2 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h2><p>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数分配一段存储空间，这段存储空间的首地址称为这个函数的地址。<font color=red>在C语言中，函数名代表的就是函数的地址</font>。既然是地址我们就可以定义指针变量来存放，那么这个指针变量就叫做函数指针变量，简称函数指针。<br />定义格式：<br />函数返回值类型（*指针变量名）（形参列表）;</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function_pointers.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">char</span> <span class="params">(*func1)</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>,<span class="type">unsigned</span> <span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">char</span> <span class="params">(**func2)</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>,<span class="type">unsigned</span> <span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">sum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> v1,<span class="type">unsigned</span> <span class="type">char</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (v1+v2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line">    func2 = &amp;func1;</span><br><span class="line">    func1 = &amp;sum;</span><br><span class="line">    a = (*func2)(<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\r\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ .\function_pointers.exe</span><br><span class="line">a = 3</span><br></pre></td></tr></table></figure><p>定义了一个指向无符号字符类型函数且有两个形参的函数指针。<br />在使用的时候，我们将函数的地址赋值给函数指针，然后就可以用函数指针来表示这个函数。</p><h2 id="函数指针数组"><a class="markdownIt-Anchor" href="#函数指针数组"></a> 函数指针数组</h2><p>字符型和整型都可以单独定义，也可以定义数组，同样函数指针也能定义数组。<br />定义格式：<br />函数返回值类型（*指针变量名[数组大小]）（形参列表）;</p><p>例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array_of_function_Pointers.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">func3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">char</span> <span class="params">(*func[<span class="number">3</span>])</span> <span class="params">()</span> </span>= &#123;func1,func2,func3&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func1 running!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func2 running!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func3 running!\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func[<span class="number">0</span>]();</span><br><span class="line">    func[<span class="number">1</span>]();</span><br><span class="line">    func[<span class="number">2</span>]();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ .\array_of_function_Pointers.exe</span><br><span class="line">func1 running!</span><br><span class="line">func2 running!</span><br><span class="line">func3 running!</span><br></pre></td></tr></table></figure><p>以上代码块中定义了三个函数和一个函数指针数组，这样就将函数放入到函数指针数组中，想要调用funct1时，不必写出函数，而是直接执行func[3] ();<br />大大提高了代码的简明性。</p><h3 id="函数指针数组控制led"><a class="markdownIt-Anchor" href="#函数指针数组控制led"></a> 函数指针数组控制LED</h3><p>接下来用一个例子来体现函数指针的优越性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LEDArrayOfFuncPointers.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    LED1,</span><br><span class="line">    LED2,</span><br><span class="line">    LED3,</span><br><span class="line">    LED_sum</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">driveLED1</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> sta)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">driveLED2</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> sta)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">driveLED3</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> sta)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">driveLEDSum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> sta)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">char</span> <span class="params">(*driveLED[<span class="number">4</span>])</span> <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> sta)</span> </span>= &#123;driveLED1,driveLED2,driveLED3,driveLEDSum&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">driveLED1</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> sta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sta)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED1 ON!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED1 OFF!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">driveLED2</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> sta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sta)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED2 ON!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED2 OFF!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">driveLED3</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> sta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sta)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED3 ON!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED3 OFF!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">driveLEDSum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> sta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sta)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED all ON!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LED all OFF!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    driveLED[LED1](<span class="number">1</span>);</span><br><span class="line">    driveLED[LED2](<span class="number">0</span>);</span><br><span class="line">    driveLED[LED3](<span class="number">1</span>);</span><br><span class="line">    driveLED[LED_sum](<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ .\LEDArrayOfFuncPointers.exe</span><br><span class="line">LED1 ON!</span><br><span class="line">LED2 OFF!</span><br><span class="line">LED3 ON!</span><br><span class="line">LED all OFF!</span><br></pre></td></tr></table></figure><p>使用函数指针似乎使代码更加复杂，实际上增强了代码的可移植性，降低了调用的难度，所以单片机厂商常常使用这种方法来构建他们的库函数，不然难以称之为一款合格的单片机。<br />而单片机应用开发者也应当尽量使用这种方法，因为这样不但能使后期维护更加方便，而且还能轻易地移植到别的单片机上，开发者在开发过程中应当形成自己的编码体系，而传统的面向过程编程难以形成完整的体系，无法形成核心竞争力。形成自身编码体系之后，好似以不变应万变，开发速度将有飞跃性提升，因为绝大多数代码都是从前写过的，移植即可。</p>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.1. C语言基础 </category>
          
          <category> 2.1.3. 程序架构内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 程序架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.3.1-从typedef和#define的差异理解typedef关键字的使用</title>
      <link href="/posts/642554d6.html"/>
      <url>/posts/642554d6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>typedef &lt;原类型&gt; &lt;新类型名&gt;：是一种语句，为已有数据类型取别名。<br />作用：使代码更加简洁易懂，用typedef定义数组、指针、结构等类型将带来很大的方便，不仅使程序书写简单而且使意义更为明确，因而增强了可读性。</p></blockquote><blockquote><p>#define &lt;宏名/标识符&gt; &lt;字符串&gt;：是一种预编译指令，在编译前会把源程序中的&lt;宏名/标识符&gt;用对应的&lt;字符串&gt;来替代。</p></blockquote><p>#define 是C中定义的语法，typedef 是 C++ 中定义的语法，二者在C++中可以通用，但 #define 成了预编译指令，typedef 当成语句处理。<br /><font color=red>Typedef 和 define 都可以用来给对象取一个别名，但是两者却有着很大不同。</font><br /><a href="https://blog.csdn.net/wangqiulin123456/article/details/8284939">参考资料1</a> <a href="https://docs.qq.com/doc/DWld2ZUt6WGZPZ1RI">参考资料2</a></p><h2 id="执行时间不同"><a class="markdownIt-Anchor" href="#执行时间不同"></a> 执行时间不同</h2><p>typedef 在编译阶段有效，所以有类型检查的功能，出现变量和数据类型错误时能及时报错。<br />而 #define 则发生在预处理阶段，只进行简单机械的字符串替换，不进行任何检查，也不占用程序空间(FLASH ROM)。</p><h2 id="功能不同"><a class="markdownIt-Anchor" href="#功能不同"></a> 功能不同</h2><hr /><p>对于 typedef ：</p><ol><li>使类型易于记忆，可定义类型别名，这些类型不只包含内部类型（int，char等），还包括自定义类型（如struct）。</li><li>简化一些比较复杂的类型声明。</li><li>定义与机器无关的类型，提高代码可移植性。在移植代码时，程序员只需要修改 typedef 后的数据类型为宿主机支持的类型即可，而不必修改整个项目中的所有类型。</li></ol><blockquote><p>例如，定义一个叫 REAL 的浮点类型，在目标机器上它可以获得最高的精度：<br />typedef long double REAL;<br />在不支持 long double 的机器上，该 typedef 看起来会是下面这样：<br />typedef double REAL;<br />并且，在连 double 都不支持的机器上，该 typedef 看起来会是这样：<br />typedef float REAL;<br />也就是说，<font color=green>跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改</font>。<br />标准库就广泛使用了这个技巧，比如 size_t 。另外，因为 typedef 是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来得稳健。</p></blockquote><hr /><p>对于 #define ：</p><ol><li>不只可以为数据类型取别名，还可以定义常量、变量、编译开关等，不过他只是单纯的替换。</li><li>可以使用 #ifdef、#ifndef 等来进行逻辑判断，还可以使用 #undef 来取消定义。</li></ol><hr /><h2 id="作用域不同因为define是预处理指令而typedef是语句"><a class="markdownIt-Anchor" href="#作用域不同因为define是预处理指令而typedef是语句"></a> 作用域不同，因为define是预处理指令，而typedef是语句</h2><p>#define 没有作用域的限制，只要是之前预定义过的宏，在宏定义以后的程序中都会被影响。而 typedef 有自己的作用域，如果在函数内部则只作用于函数。</p><h2 id="对指针的操作"><a class="markdownIt-Anchor" href="#对指针的操作"></a> 对指针的操作</h2><p>二者修饰指针类型时，作用不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Typedef <span class="type">int</span> *pint;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PINT int *</span></span><br><span class="line"><span class="type">const</span> pint p; <span class="comment">//等同于pint const p; p不可更改，p指向的内容可以更改，相当于 int * const p;</span></span><br><span class="line"><span class="type">const</span> PINT p; <span class="comment">//p可以更改，p指向的内容不能更改，相当于 const int *p;或 int const *p;</span></span><br><span class="line">pint s1, s2;  <span class="comment">//s1和s2都是int型指针</span></span><br><span class="line">PINT s3, s4;  <span class="comment">//相当于int *s3，s4；只有一个是指针。 </span></span><br></pre></td></tr></table></figure><h2 id="理解和使用typedef的小技巧"><a class="markdownIt-Anchor" href="#理解和使用typedef的小技巧"></a> ⭐理解和使用typedef的小技巧</h2><p>对于一句 typedef 语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*p)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>以上语句执行之后，与以下两条语句等效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p SHAN;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> (*SHAN)(<span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>要定义的类型是 char (*)(int)，即参数为 int ，返回值类型为字符的函数指针，定义的别名是p。<br />简单地说，就是把 typedef 后面别名以外的部分视为一个整体，将这个整体用这个别名来表示，以此简化数据类型形式，提高代码可读性。</p>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.1. C语言基础 </category>
          
          <category> 2.1.3. 程序架构内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 程序架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.3.3-无线门磁探测器软件设计</title>
      <link href="/posts/34287.html"/>
      <url>/posts/34287.html</url>
      
        <content type="html"><![CDATA[<h2 id="软件开发必要条件"><a class="markdownIt-Anchor" href="#软件开发必要条件"></a> 软件开发必要条件</h2><h3 id="stc-51单片机开发环境"><a class="markdownIt-Anchor" href="#stc-51单片机开发环境"></a> STC 51单片机开发环境</h3><p>常用的单片机开发环境 Keil、IAR。将STC头文件导入到软件文件夹内。利用STC-ISP中的范例程序进行高效率的开发。</p><h3 id="单片机c语言"><a class="markdownIt-Anchor" href="#单片机c语言"></a> 单片机C语言</h3><p>定义变量的方法<br />算数逻辑运算符的使用<br />if、while、for、switch/case、do-while语句<br />头文件的用途与调用，头文件是硬件和软件关联的关键。</p><p>详情见板块“C语言基础”。</p><h2 id="无线门磁探测器软件逻辑"><a class="markdownIt-Anchor" href="#无线门磁探测器软件逻辑"></a> 无线门磁探测器软件逻辑</h2><p>门磁探测器软件共可分为四块：IO口初始化配置、门磁开关检测程序设计、低压检测程序设计、射频电路程序设计。<br />其中，IO口初始化配置并非放在第一步直接完成，应根据模块需求对接口进行配置。<br />STC15W10X系列芯片如下图所示。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.3/STC15W10X%E7%B3%BB%E5%88%97%E8%8A%AF%E7%89%87.png" alt="P2.1-STC15W10X系列芯片.png" /></p><h3 id="io口初始化配置"><a class="markdownIt-Anchor" href="#io口初始化配置"></a> IO口初始化配置</h3><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.3/IO%E5%8F%A3%E6%A8%A1%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE.png" alt="P2.2-IO口模式初始化配置.png" /></p><p>以MCU为核心，看MCU的中英文资料，根据每个接口的用途，确定各个管脚的工作模式，编写初始化代码。</p><p>关于IO口的各种模式，此博客中有详细的介绍: <a href="https://blog.csdn.net/techexchangeischeap/article/details/72569999">GPIO输入输出各种模式详解</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">推挽输出能输出大电流，能点亮LED灯。</span><br><span class="line">开漏模式省电，可用于接收外部电平变化并进入中断。</span><br></pre></td></tr></table></figure><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.3/MCU%E7%94%B5%E8%B7%AF.png" alt="P2.3-MCU电路.png" /></p><p>所有接口都可利用宏定义进行命名，如下图。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.3/%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%91%BD%E5%90%8D%E8%8A%AF%E7%89%87%E6%8E%A5%E5%8F%A3.png" alt="P2.4-宏定义命名芯片接口.png" /></p><h4 id="led驱动引脚p30-p31"><a class="markdownIt-Anchor" href="#led驱动引脚p30-p31"></a> LED驱动引脚（P3.0、P3.1）</h4><p>如 P2.3 电路图所示，P3.0和P3.1需要实现推挽输出，推挽输出驱动能力比开漏输出更高，可点亮LED灯。（<font color=red>后续应当根据小灯泡亮度实际情况对IO口工作模式做出调整</font>）</p><p>P3.0口配置：P3M0.0置1；P3M1.0置0<br />P3.1口配置：P3M0.1置1；P3M1.1置0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P3.0和P3.1为推挽输出口，应选择推挽输出模式</span></span><br><span class="line">P3M0 |= <span class="number">0x03</span>;     <span class="comment">// P3M0后两位置1，其他位保留</span></span><br><span class="line">P3M1 &amp;= (~<span class="number">0x03</span>);  <span class="comment">// P3M0后两位置0，其他位保留</span></span><br></pre></td></tr></table></figure><p>寄存器配置方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">某几位置1，其他位不变：“|=（0x??）”；</span><br><span class="line">某几位置0，其他位不变：“&amp;=（~0x??）”。</span><br><span class="line">其中 0x?? 由需要操作的位来决定，例如需要对第1位和第4位操作，那么此时0x??=0x09=b00001001</span><br><span class="line">  或生1，与生0</span><br></pre></td></tr></table></figure><h4 id="开关门状态反馈引脚p34-p35"><a class="markdownIt-Anchor" href="#开关门状态反馈引脚p34-p35"></a> 开关门状态反馈引脚（P3.4、P3.5）</h4><p>分析开关门检测口P3.4和P3.5，这两个口都是输入性质的口，可以直接检测到外部的开关门信号，但是这种方法需要单片机一直处于工作状态，耗电量大，因此使用中断服务程序INT2和INT3，查数据表可知这两个接口均只支持下降沿中断。编写好中断服务程序使能和中断服务程序入口备用。<font color=red>将两个中断口设置为开漏模式，开漏模式待机状态更加省电。</font></p><h4 id="电池低压状态引脚p33"><a class="markdownIt-Anchor" href="#电池低压状态引脚p33"></a> 电池低压状态引脚（P3.3）</h4><p>开漏模式</p><h4 id="射频电路信号输出引脚p32"><a class="markdownIt-Anchor" href="#射频电路信号输出引脚p32"></a> 射频电路信号输出引脚（P3.2）</h4><p>准双向口</p><h3 id="门磁开关检测程序设计指示灯p30-开门上升沿p34-关门上升沿p35"><a class="markdownIt-Anchor" href="#门磁开关检测程序设计指示灯p30-开门上升沿p34-关门上升沿p35"></a> 门磁开关检测程序设计（指示灯P3.0、开门上升沿P3.4、关门上升沿P3.5）</h3><p>开门和关门操作都应该进入中断服务程序，对开关门flag起作用，程序再根据门的当前状态，对操作定性，来确定是否点亮工作指示灯。<br />门磁开关检测：INT2下降沿检测关门，INT3下降沿检测开门，因此定义变量flag_Door，关门时进入INT2使其为1，开门时进入INT3使其为2。</p><h3 id="低压检测程序设计指示灯p31-低压下降沿p33"><a class="markdownIt-Anchor" href="#低压检测程序设计指示灯p31-低压下降沿p33"></a> 低压检测程序设计（指示灯P3.1、低压下降沿P3.3）</h3><p>当电池低压检测电路产生下降沿输出时，进入中断服务程序，对低压flag起作用，程序再根据电池当前状态，对状态定性，来确定是否点亮低压指示灯。<br />低压检测电路：电池低压时，进入INT1</p><h3 id="射频电路程序设计信号输出端口p32"><a class="markdownIt-Anchor" href="#射频电路程序设计信号输出端口p32"></a> 射频电路程序设计（信号输出端口P3.2）</h3><p>本项目射频电路编码方式参考编码器EV1527，无线发射模块中没有EV1527，为节约成本，编程实现EV1527的编码功能，其中文资料如下：</p><p><a href="https://oss.magicconch.top/api/raw/?path=/files/EV1527%E7%99%BE%E4%B8%87%E7%BB%84%E7%BC%96%E7%A0%81%E8%8A%AF%E7%89%87%E8%A7%84%E6%A0%BC%E4%B9%A6.pdf">EV1527百万组编码芯片规格书.pdf</a></p><p>如下图所示，在EV1527编码方式中，每次会发送3byte（24bit）的信号，前20bit（C0-C19）代表信号的地址，是接收器识别信号的依据，后4bit（D0-D3）为功能码，可表示15种功能。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.3/EV1527%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F.png" alt="P2.5-EV1527编码格式.png" /></p><p>载波信号的OOK编码规则如下图所示。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.3/%E8%BD%BD%E6%B3%A2%E4%BF%A1%E5%8F%B7OOK%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99.png" alt="P2.6-载波信号OOK编码规则.png" /></p><p>因此需要利用单片机中的定时器，对信号地址和功能码进行处理，使之编码为如下图中的信号，再通过震荡电路产生无线信号，从而被WIFI报警主机接收到。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.3/%E5%AE%9E%E9%99%85%E8%BE%93%E5%87%BA%E4%BF%A1%E5%8F%B7.jpg" alt="P2.7实际输出信号.jpg" /></p><p>查找EV1527数据手册可得，在3V工作电压，330kΩ外加电阻的情况下，16CLK=1.69ms，1CLK=0.1ms，因此可得到以下的结论：</p><table><thead><tr><th>信号类型</th><th>高电平时钟数</th><th>低电平时钟数</th><th></th><th>低电平时长</th><th>低电平时长</th></tr></thead><tbody><tr><td>同步</td><td>4CLK</td><td>124CLK</td><td>-&gt;</td><td>0.4ms</td><td>12.8ms</td></tr><tr><td>0</td><td>4CLK</td><td>12CLK</td><td>-&gt;</td><td>0.4ms</td><td>1.2ms</td></tr><tr><td>1</td><td>12CLK</td><td>4CLK</td><td>-&gt;</td><td>1.2ms</td><td>0.4ms</td></tr></tbody></table><p>12T和1T单片机的区别和认识：<br />1T的速度更快，最小间隔是一个晶振周期。</p><p>计算nT单片机的指令周期公式为：</p><blockquote><p>T = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>f</mi></mfrac><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\frac{1}{f}*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span><br />f: 晶振频率</p></blockquote><p>例如： 使用12M晶振的1T单片机的指令周期为：T = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>12</mn></mfrac><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{1}{12}*1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>12</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{1}{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> us。</p><p>定时器本质上是一个加法器，单片机的位数 n 、晶振频率 f 和 12T or 1T 共同决定了定时器计时的最大时长。12T单片机最大时长 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn><mi>T</mi><mo>=</mo><mfrac><mn>1</mn><mi>f</mi></mfrac><mo>∗</mo><msup><mn>2</mn><mi>n</mi></msup><mo>∗</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">12T = \frac{1}{f}*2^n*12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span> ，1T单片机最大时长 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>T</mi><mo>=</mo><mfrac><mn>1</mn><mi>f</mi></mfrac><mo>∗</mo><msup><mn>2</mn><mi>n</mi></msup><mo>∗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1T = \frac{1}{f}*2^n*1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.326216em;vertical-align:-0.481108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span><br />设置TH0和TL0为计时初始值，加法器运行到溢出时停止计时。</p><p>此处用的是12T非自动重载16位定时器，f = 5.5296MHz</p><table><thead><tr><th>时长</th><th>TH0</th><th>TL0</th></tr></thead><tbody><tr><td>12.8ms</td><td>0xE8</td><td>0xF5</td></tr><tr><td>1.2ms</td><td>0xFD</td><td>0xD6</td></tr><tr><td>0.4ms</td><td>0xFF</td><td>0x47</td></tr></tbody></table><p>自动重载定时器：溢出时将自动重新设置TH0和TL0。</p><h2 id="stc单片机程序开发"><a class="markdownIt-Anchor" href="#stc单片机程序开发"></a> STC单片机程序开发</h2><ol><li>保存头文件到项目文件夹。</li><li>对接口进行初始化配置。</li><li>分析各个模块，从而设置各个接口的工作模式（开漏、准双向口、推挽输出、高阻输入）。功耗：推挽输出＞准双向口＞开漏＞高阻输入。</li><li>根据各个模块的功能编写相应的程序。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">项目说明: </span></span><br><span class="line"><span class="comment">MCU 型号: STC15F104W 单片机</span></span><br><span class="line"><span class="comment">开发环境: Keil C91    版本: V9.59.0.0</span></span><br><span class="line"><span class="comment">主要功能包括： 开门检测   关门检测   OOK无线编码  设备休眠</span></span><br><span class="line"><span class="comment">///主机要求    开门发射数据4  关门5  电池低压 6</span></span><br><span class="line"><span class="comment">单片机晶振：   内部5.5296M</span></span><br><span class="line"><span class="comment">主要使用单片机资源：</span></span><br><span class="line"><span class="comment">  &gt;&gt; IO 输出</span></span><br><span class="line"><span class="comment">  &gt;&gt; 外部中断1</span></span><br><span class="line"><span class="comment">  &gt;&gt; 外部中断2</span></span><br><span class="line"><span class="comment">  &gt;&gt; 外部中断3</span></span><br><span class="line"><span class="comment">  &gt;&gt; 定时器  0</span></span><br><span class="line"><span class="comment">LED灯状态说明：</span></span><br><span class="line"><span class="comment">  休    眠：灭</span></span><br><span class="line"><span class="comment">  电池低压：    每次门状态改变后 黄灯闪烁一次  (黄色灯)</span></span><br><span class="line"><span class="comment">  设备状态改变：设备LED闪烁一次                (蓝色灯)</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;STC15WXX.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;absacc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">System_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OOKDataSent</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> SentDat)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Hard_Pro</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SystmPro</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Sleep_Pro</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_WORK_STA   P31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW_BAT     P30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_DOOR_OPEN  P35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STA_DOOR_CLOSE P34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BAT_LOW        P33</span></span><br><span class="line"></span><br><span class="line">sbit OOK_DAT_OUT = P3^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> flag_Door;      <span class="comment">//  =0 无动作    1关门      2 开门</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> DoorSta;        <span class="comment">//  =0 无动作    1关门      2 开门</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> flag_VlotLow;   <span class="comment">//  =0 电池正常  1电池低压  2电池低压中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//12.8毫秒 TH0 TL0 的数据   寄存器计数 = (12.8ms * 1000)/ A = 5899    TH0 TL0 = 65535 - 5899 = 59636  E8F4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OOK_TONG_H    0xE8    <span class="comment">// 同步头高位 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OOK_TONG_L    0xF4    <span class="comment">// 同步头低位</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0.4毫秒  TH0 TL0 的数据   寄存器计数 = (0.4ms * 1000)/ A = 184      TH0 TL0 = 65535 - 184 = 65351   FF47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OOK_SMALL_H     0xFF  <span class="comment">// 小脉冲高位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OOK_SMALL_L     0x47  <span class="comment">// 小脉冲低位</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.2毫秒  TH0 TL0 的数据   寄存器计数 = (1.2ms * 1000) / A = 553     TH0 TL0 = 65535 - 553 = 64982   FDD6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OOK_LONG_H      0xFD  <span class="comment">// 大脉冲高位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OOK_LONG_L      0xD6  <span class="comment">// 大脉冲低位</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> coding[<span class="number">100</span>];    <span class="comment">// 数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay10ms</span><span class="params">()</span>    <span class="comment">//@5.5296MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i, j;</span><br><span class="line">  i = <span class="number">54</span>;</span><br><span class="line">  j = <span class="number">199</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> (--j);</span><br><span class="line">  &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay100ms</span><span class="params">()</span>    <span class="comment">//@5.5296MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i, j, k;</span><br><span class="line"><span class="comment">//  _nop_();</span></span><br><span class="line"><span class="comment">//  _nop_();</span></span><br><span class="line">  i = <span class="number">3</span>;</span><br><span class="line">  j = <span class="number">26</span>;</span><br><span class="line">  k = <span class="number">223</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (--k);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--j);</span><br><span class="line">  &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay3000ms</span><span class="params">()</span>    <span class="comment">//@5.5296MHz</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i, j, k;</span><br><span class="line">  _nop_();</span><br><span class="line">  _nop_();</span><br><span class="line">  i = <span class="number">64</span>;</span><br><span class="line">  j = <span class="number">9</span>;</span><br><span class="line">  k = <span class="number">179</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (--k);</span><br><span class="line">    &#125; <span class="keyword">while</span> (--j);</span><br><span class="line">  &#125; <span class="keyword">while</span> (--i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////// 主程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  System_Init();    <span class="comment">// 系统初始化程序</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Hard_Pro();     <span class="comment">// 硬件检测</span></span><br><span class="line">    SystmPro();     <span class="comment">// LED灯亮  OOK 数据发送</span></span><br><span class="line">    Sleep_Pro();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">函数说明: </span></span><br><span class="line"><span class="comment">函数名称：SystmPro(void)</span></span><br><span class="line"><span class="comment">功    能: OOK/ASK 无线数据编码程序</span></span><br><span class="line"><span class="comment">参    数: 系统LED灯闪烁  OOK 数据发送</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Sleep_Pro</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;  </span><br><span class="line">    _nop_();      <span class="comment">//掉电模式被唤醒后,首先执行此语句,然后再进入中断服务程序</span></span><br><span class="line">    _nop_();</span><br><span class="line">    PCON = <span class="number">0x02</span>;  <span class="comment">//MCU进入掉电模式</span></span><br><span class="line">    _nop_();      <span class="comment">//掉电模式被唤醒后,首先执行此语句,然后再进入中断服务程序</span></span><br><span class="line">    _nop_();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Hard_Pro</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(flag_Door == <span class="number">1</span>)</span><br><span class="line">  &#123;<span class="comment">//门关闭</span></span><br><span class="line">    flag_Door = <span class="number">0</span>;</span><br><span class="line">    Delay10ms();</span><br><span class="line">    <span class="keyword">if</span>(STA_DOOR_CLOSE == <span class="number">0</span>)</span><br><span class="line">    &#123;<span class="comment">//门确定关闭 </span></span><br><span class="line">      DoorSta  = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(flag_Door == <span class="number">2</span>)</span><br><span class="line">  &#123;<span class="comment">//门打开</span></span><br><span class="line">    flag_Door = <span class="number">0</span>;</span><br><span class="line">    Delay10ms();</span><br><span class="line">    <span class="keyword">if</span>(STA_DOOR_OPEN == <span class="number">0</span>)</span><br><span class="line">    &#123;<span class="comment">//门确定打开</span></span><br><span class="line">      DoorSta  = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    flag_Door = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag_VlotLow == <span class="number">1</span>)</span><br><span class="line">  &#123;<span class="comment">////电池低压</span></span><br><span class="line">    Delay10ms();</span><br><span class="line">    <span class="keyword">if</span>(BAT_LOW == <span class="number">0</span>)</span><br><span class="line">    &#123;<span class="comment">////电池第一次低压</span></span><br><span class="line">      flag_VlotLow = <span class="number">2</span>;</span><br><span class="line">      YELLOW_BAT = <span class="number">1</span>;     <span class="comment">//工作状态灯打开</span></span><br><span class="line">      OOKDataSent(<span class="number">0x06</span>);</span><br><span class="line">      YELLOW_BAT = <span class="number">0</span>;     <span class="comment">//工作状态灯关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      flag_VlotLow = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">函数说明: </span></span><br><span class="line"><span class="comment">函数名称：SystmPro(void)</span></span><br><span class="line"><span class="comment">功    能: OOK/ASK 无线数据编码程序</span></span><br><span class="line"><span class="comment">参    数: 系统LED灯闪烁  OOK 数据发送</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SystmPro</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(DoorSta)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">//    LED_WORK_STA = 1;   ///工作状态灯打开</span></span><br><span class="line">    Delay10ms();</span><br><span class="line">    <span class="keyword">if</span>(DoorSta == <span class="number">1</span>)</span><br><span class="line">    &#123; <span class="comment">////关门无线数据发送</span></span><br><span class="line">      OOKDataSent(<span class="number">0x0E</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">///if(DoorSta == 2)</span></span><br><span class="line">    &#123; <span class="comment">////开门无线数据发送     </span></span><br><span class="line">      OOKDataSent(<span class="number">0x0A</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    LED_WORK_STA = 0;   ///工作状态灯关闭</span></span><br><span class="line">    DoorSta = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(flag_VlotLow == <span class="number">2</span>)</span><br><span class="line">  &#123;<span class="comment">////电池低压提示</span></span><br><span class="line">    YELLOW_BAT = <span class="number">1</span>;       <span class="comment">///工作状态灯打开</span></span><br><span class="line">    Delay100ms();</span><br><span class="line">    YELLOW_BAT = <span class="number">0</span>;       <span class="comment">///工作状态灯关闭</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">System_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;<span class="comment">///// 端口初始化</span></span><br><span class="line">    P0M0 = <span class="number">0x00</span>;</span><br><span class="line">    P0M1 = <span class="number">0x00</span>;</span><br><span class="line">    P1M0 = <span class="number">0x00</span>;</span><br><span class="line">    P1M1 = <span class="number">0x00</span>;</span><br><span class="line">    P2M0 = <span class="number">0x00</span>;</span><br><span class="line">    P2M1 = <span class="number">0x00</span>;</span><br><span class="line">    P3M0 = <span class="number">0x00</span>;</span><br><span class="line">    P3M1 = <span class="number">0x00</span>;</span><br><span class="line">    P4M0 = <span class="number">0x00</span>;</span><br><span class="line">    P4M1 = <span class="number">0x00</span>;</span><br><span class="line">    P5M0 = <span class="number">0x00</span>;</span><br><span class="line">    P5M1 = <span class="number">0x00</span>;</span><br><span class="line">    P6M0 = <span class="number">0x00</span>;</span><br><span class="line">    P6M1 = <span class="number">0x00</span>;</span><br><span class="line">    P7M0 = <span class="number">0x00</span>;</span><br><span class="line">    P7M1 = <span class="number">0x00</span>;</span><br><span class="line">    </span><br><span class="line">    STA_DOOR_OPEN = <span class="number">1</span>;</span><br><span class="line">    STA_DOOR_CLOSE = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    P3M1 |= <span class="number">0x20</span>;</span><br><span class="line">    P3M0 |= <span class="number">0x20</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    P3M1 |= 0x30;</span></span><br><span class="line"><span class="comment">//    P3M0 |= 0x30;</span></span><br><span class="line">    </span><br><span class="line">    OOK_DAT_OUT = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    INT0 = 1;</span></span><br><span class="line">    IT1 = <span class="number">1</span>;                    <span class="comment">//设置INT0的中断类型 (1:仅下降沿 0:上升沿和下降沿)</span></span><br><span class="line">    EX1 = <span class="number">1</span>;                    <span class="comment">//使能INT0中断</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    INT_CLKO |= <span class="number">0x10</span>;               <span class="comment">//(EX2 = 1)使能INT2中断</span></span><br><span class="line">    INT_CLKO |= <span class="number">0x20</span>;               <span class="comment">//(EX3 = 1)使能INT3中断</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    AUXR |= 0x80;                   //定时器0为1T模式</span></span><br><span class="line">    AUXR &amp;= <span class="number">0x7f</span>;                   <span class="comment">//定时器0为12T模式</span></span><br><span class="line">    TMOD = <span class="number">0x00</span>;                    <span class="comment">//设置定时器为模式0(16位自动重装载)</span></span><br><span class="line"><span class="comment">//    TL0 = T1MS;                     //初始化计时值</span></span><br><span class="line"><span class="comment">//    TH0 = T1MS &gt;&gt; 8;</span></span><br><span class="line">    TR0 = <span class="number">0</span>;                        <span class="comment">//定时器0开始计时</span></span><br><span class="line">    ET0 = <span class="number">0</span>;                        <span class="comment">//使能定时器0中断</span></span><br><span class="line">    EA = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    LED_WORK_STA = <span class="number">1</span>;  <span class="comment">///开机 蓝灯  黄灯 长亮 3秒</span></span><br><span class="line">    YELLOW_BAT = <span class="number">1</span>;</span><br><span class="line">    Delay3000ms();</span><br><span class="line">    LED_WORK_STA = <span class="number">0</span>;</span><br><span class="line">    YELLOW_BAT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    flag_Door = <span class="number">0</span>;     <span class="comment">// =0 无动作    1关门      2 开门</span></span><br><span class="line">    DoorSta = <span class="number">0</span>;       <span class="comment">// =0 无动作    1关门      2 开门</span></span><br><span class="line">    flag_VlotLow = <span class="number">0</span>;  <span class="comment">// =0 电池正常  1电池低压  2电池低压中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">函数说明: </span></span><br><span class="line"><span class="comment">函数名称：void OOKDataSent(unsigned char SentDat</span></span><br><span class="line"><span class="comment">功    能: OOK/ASK 无线数据编码程序</span></span><br><span class="line"><span class="comment">参    数: SentDat 无线数据 功能码  </span></span><br><span class="line"><span class="comment">          有效数据范围:00H-0FH</span></span><br><span class="line"><span class="comment">详细函数说明：</span></span><br><span class="line"><span class="comment">    编码方式:  EV1527 兼容</span></span><br><span class="line"><span class="comment">    无线数据地址：</span></span><br><span class="line"><span class="comment">       从单片机Flash FF6-FF8 获取</span></span><br><span class="line"><span class="comment">        Flash地址烧录方式:  通过烧录器滚码烧录  共三个字节 FF6高位4位无效</span></span><br><span class="line"><span class="comment">工作原理:</span></span><br><span class="line"><span class="comment">    单片机内部定时器0中断触发后 不断的修改内部的定时器时间  最终达到规则的定时器</span></span><br><span class="line"><span class="comment">    规则。</span></span><br><span class="line"><span class="comment">    将定时器的定时时间存入  coding[100]中。每帧数据共25数据。每个数据一个正负脉冲</span></span><br><span class="line"><span class="comment">共需要50个字节  每个定时器时间需要高位和低位两个字节  共100个字节</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OOKDataSent</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> SentDat)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i,j,dat;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> data2,data1,data0;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line"><span class="comment">//  data2=CBYTE[0xFF6];</span></span><br><span class="line">  data1=CBYTE[<span class="number">0xFF7</span>];</span><br><span class="line">  data0=CBYTE[<span class="number">0xFF8</span>];</span><br><span class="line"><span class="comment">//  ////将OOK 数据的功能码添加到发射数据中</span></span><br><span class="line"><span class="comment">//  data2 &amp;= 0xf0;   //低4位清0</span></span><br><span class="line"><span class="comment">//  SentDat &amp;= 0x0f;  //将功能码整合到数据中 </span></span><br><span class="line"><span class="comment">//  data2 |= SentDat;</span></span><br><span class="line">  </span><br><span class="line">  data2 = SentDat;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">////同步信号   </span></span><br><span class="line">  <span class="comment">////0.4毫秒高电平</span></span><br><span class="line">  coding[<span class="number">0</span>]  = OOK_SMALL_H;</span><br><span class="line">  coding[<span class="number">1</span>]  = OOK_SMALL_L;</span><br><span class="line">  <span class="comment">////12.8毫秒低电平</span></span><br><span class="line">  coding[<span class="number">2</span>]  = OOK_TONG_H;</span><br><span class="line">  coding[<span class="number">3</span>]  = OOK_TONG_L;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">4</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      dat = data0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">36</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      dat = data1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">68</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      dat = data2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(dat &amp; <span class="number">0x80</span>)</span><br><span class="line">      &#123;<span class="comment">///</span></span><br><span class="line">      <span class="comment">////0.4毫秒高电平</span></span><br><span class="line">        <span class="comment">/////1.2毫秒 高电平</span></span><br><span class="line">        coding[i]  = OOK_LONG_H;</span><br><span class="line">        i++;</span><br><span class="line">        coding[i]  = OOK_LONG_L;</span><br><span class="line">        i++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">////0.4毫秒低电平</span></span><br><span class="line">        coding[i]  = OOK_SMALL_H;</span><br><span class="line">        i++;</span><br><span class="line">        coding[i]  = OOK_SMALL_L;  <span class="comment">//i++;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        coding[i]  = OOK_SMALL_H;</span><br><span class="line">        i++;</span><br><span class="line">        coding[i]  = OOK_SMALL_L;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//////1.2毫秒  低电平</span></span><br><span class="line">        coding[i]  = OOK_LONG_H;</span><br><span class="line">        i++;</span><br><span class="line">        coding[i]  = OOK_LONG_L;</span><br><span class="line">        <span class="comment">//i++;      </span></span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">      dat &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//// 65432187</span></span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">  &#125;</span><br><span class="line">  TR0 = <span class="number">1</span>;         <span class="comment">//定时器0开始计时</span></span><br><span class="line">  ET0 = <span class="number">0</span>;         <span class="comment">//使能定时器0中断</span></span><br><span class="line">  </span><br><span class="line">  LED_WORK_STA = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  P3M0 |= <span class="number">0X04</span>;</span><br><span class="line">   OOK_DAT_OUT = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">23</span>;j++)<span class="comment">////发射数据的帧数</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">    &#123;<span class="comment">////一帧数据</span></span><br><span class="line">      TF0 = <span class="number">0</span>;</span><br><span class="line">      OOK_DAT_OUT = !OOK_DAT_OUT;<span class="comment">// = !P_RFSENT;</span></span><br><span class="line">      TH0 = coding[i];</span><br><span class="line">      i++;</span><br><span class="line">      TL0 =  coding[i];</span><br><span class="line">      <span class="keyword">while</span>(!TF0)</span><br><span class="line">      &#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">////检测定时器0 的中断标志位 TF0 =1 表示延时完成</span></span><br><span class="line">        <span class="comment">//  TF0 =0;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  TF0 = <span class="number">0</span>;</span><br><span class="line">  TR0 = <span class="number">0</span>;</span><br><span class="line">  OOK_DAT_OUT = <span class="number">0</span>;</span><br><span class="line">  LED_WORK_STA = <span class="number">0</span>;</span><br><span class="line">  P3M0 &amp;= ~<span class="number">0X04</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------</span></span><br><span class="line"><span class="comment">//中断服务程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exint0</span><span class="params">()</span> interrupt 0       <span class="comment">//INT0中断入口</span></span><br><span class="line">&#123;<span class="comment">//  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Timer0 interrupt routine */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exint1</span><span class="params">()</span> interrupt 2</span><br><span class="line">&#123;<span class="comment">//电池低压</span></span><br><span class="line">  flag_VlotLow = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//  P10 = ! P10;                    //将测试口取反</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------</span></span><br><span class="line"><span class="comment">//中断服务程序 开门检测</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exint3</span><span class="params">()</span> interrupt 11          <span class="comment">//INT3中断入口</span></span><br><span class="line">&#123;</span><br><span class="line">  flag_Door = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断服务程序 关门检测</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exint2</span><span class="params">()</span> interrupt 10          <span class="comment">//INT2中断入口</span></span><br><span class="line">&#123;</span><br><span class="line">  flag_Door = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.3. 实战项目一：无线门磁探测器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> 项目实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.3.2-无线门磁探测器硬件设计</title>
      <link href="/posts/46919.html"/>
      <url>/posts/46919.html</url>
      
        <content type="html"><![CDATA[<h2 id="硬件设计流程"><a class="markdownIt-Anchor" href="#硬件设计流程"></a> 硬件设计流程</h2><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B.webp" alt="P1.1-硬件设计流程.webp" /></p><h2 id="关键物料选型"><a class="markdownIt-Anchor" href="#关键物料选型"></a> 关键物料选型</h2><p>MCU: STC15W104<br />干簧管: 磁簧开关(Reed Switch)也称之为干簧管，它是一个通过所施加的磁场操作的电开关。基本型式是将两片磁簧片密封在玻璃管内，两片虽重叠，但中间间隔有一小空隙。当外来磁场时将使两片磁簧片接触，进而导通。 一旦磁体被拉到远离开关，磁簧开关将返回到其原来的位置。<br />电源模块: &quot;12A&quot;电池 + HT7530稳压管</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E5%B9%B2%E7%B0%A7%E7%AE%A1.webp" alt="P2.1-干簧管.webp" /></p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E6%88%90%E6%9C%AC%E5%88%9D%E6%AD%A5%E6%A0%B8%E7%AE%97.webp" alt="P2.2-成本初步核算.webp" /></p><h2 id="pcb设计软件altium-designer"><a class="markdownIt-Anchor" href="#pcb设计软件altium-designer"></a> PCB设计软件(Altium Designer)</h2><p><a href="https://www.bilibili.com/video/BV1GL411V7QP/?from=search&amp;seid=3435152784139761603&amp;spm_id_from=333.337.0.0&amp;vd_source=723bcc95ea546f87d4985cbd117c5454">Altium Designer安装</a></p><p>理解原理图、PCB、原理图库、PCB库。<br />注意建立完成的工程的后缀对应的文件。<br />AD设计不是为了电路仿真，是为了导出印刷电路板，电路仿真可以考虑使用Multisim。</p><h2 id="无线门磁探测器原理图设计以及绘制"><a class="markdownIt-Anchor" href="#无线门磁探测器原理图设计以及绘制"></a> 无线门磁探测器原理图设计以及绘制</h2><p>理解visible grid和snap grid。<br />元件库的建立以及元件库内元件的设计，放置。（设计干簧管）<br />电磁控制电路和电源电路的讲解，干簧管控制输入电源的电平高低，电源电路采用HT7530将12V电压输出为3V电压。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/DoorSensor%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="P4.0-DoorSensor原理图.png" /></p><h3 id="电源模块"><a class="markdownIt-Anchor" href="#电源模块"></a> 电源模块</h3><p>使用23A电池，12V输入电压，应使用HT7530芯片将电压稳定在为3V。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E7%94%B5%E6%BA%90%E6%A8%A1%E5%9D%97.png" alt="P4.1-电源模块.png" /></p><h3 id="门磁开关检测模块"><a class="markdownIt-Anchor" href="#门磁开关检测模块"></a> 门磁开关检测模块</h3><p>关门状态下，干簧管闭合，GUAN处于低电平，三极管关断，KAI为高电平；开门状态下。干簧管开路，GUAN处于高电平，三极管通路KAI处于低电平。总结：关门时，GUAN下降沿；开门时，KAI下降沿。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E9%97%A8%E7%A3%81%E5%BC%80%E5%85%B3%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9D%97.png" alt="P4.2-门磁开关检测模块.png" /></p><h3 id="电池低压检测模块"><a class="markdownIt-Anchor" href="#电池低压检测模块"></a> 电池低压检测模块</h3><p>用于检测电池健康度。当电池电压较低时，Q3不导通，Q2导通，Volt_LOW处于低电平；当电池电压较高时，Q3导通，Q2不导通，Volt_LOW处于高电平。总结：当电池电量不足时，Volt_LOW有下降沿。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E7%94%B5%E6%B1%A0%E4%BD%8E%E5%8E%8B%E6%A3%80%E6%B5%8B%E6%A8%A1%E5%9D%97.png" alt="P4.3-电池低压检测模块.png" /></p><h3 id="射频模块"><a class="markdownIt-Anchor" href="#射频模块"></a> 射频模块</h3><p>需要由射频硬件工程师来完成，或者使用现成解决方案。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E5%B0%84%E9%A2%91%E6%A8%A1%E5%9D%97.png" alt="P4.4-射频模块.png" /></p><h3 id="mcu电路"><a class="markdownIt-Anchor" href="#mcu电路"></a> MCU电路</h3><p>由STC15W104的芯片手册可知INT0、INT1支持上升沿和下降沿中断，INT2、INT3、INT4只支持下降沿中断，以此来确定开门关门以及低压检测所在中断的引脚。并且应当注意单片机烧录引脚不应该加上拉或者下拉电源，可能会导致烧录失败。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/MCU%E7%94%B5%E8%B7%AF.png" alt="P4.5-MCU电路.png" /></p><h2 id="印刷电路板pcb绘制"><a class="markdownIt-Anchor" href="#印刷电路板pcb绘制"></a> 印刷电路板(PCB)绘制</h2><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/PCB%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.webp" alt="P5.1-PCB设计基本流程.webp" /></p><p><a href="https://www.bilibili.com/video/BV1d44y1b7Cc/?from=search&amp;seid=9813390614045852435&amp;spm_id_from=333.337.0.0">基于Altium Designer的PCB绘制</a></p><p>概要：</p><ol><li>建库。画PcbLib与SchLib（可利用<a href="https://www.szlcsc.com/">立创商城</a>）</li><li>绘制原理图。将SchLib内的元件拿出放入到SchDoc，连接元件并检查原理图的正确性</li><li>绘制电路图。依据加工厂设计能力设置电路板的极限参数建立规则，将原理图关系导入到电路图中（Pcb与Sch以网表相关联），进行PCB布局布线和PCB规则检查。</li></ol><h3 id="建库"><a class="markdownIt-Anchor" href="#建库"></a> 建库</h3><h4 id="新建工程"><a class="markdownIt-Anchor" href="#新建工程"></a> 新建工程</h4><ol><li>文件-新的-项目，设置好项目名称和项目文件路径，AD将在对应路径下新建一个与项目名称相同的文件夹放置项目文件。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B(1).png" alt="P5.2-新建工程(1).png" /></li><li>在文件夹下新建lib、sch、pcb三个空文件夹。</li><li>右键左侧projects栏中对应工程，分别建立SchLib、PcbLib、SchDoc、PcbDoc；将SchLib、PcbLib命名保存到工程目录的lib文件夹内，将SchDoc、PcbDoc命名分别保存到sch与pcb文件夹内。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B(2).png" alt="P5.3-新建工程(2).png" /></li></ol><h4 id="绘制pcblib"><a class="markdownIt-Anchor" href="#绘制pcblib"></a> 绘制PcbLib</h4><p>绘制PcbLib有四个步骤：元件起名、放置引脚、放置丝印、放置3D外框。<br />打开PCB Library选项卡，进入PcbLib绘制阶段。</p><ol><li><p>元件起名：在封装（FootPrints）栏中右键选择New Blank Footprint，双击器件以编辑。<br />打开芯片的数据手册，记录芯片引脚之间的最远与最近距离、芯片封装体的长宽高等芯片参数。<br />tips：画PcbLib类似于画PcbDoc，有层的定义，分为顶层（Top Layer）、底层（Bottom Layer）、机械层（Mechanical Layer）、丝印层（Top Overlay）、通孔层（Multi-Layer）。<font color=red>在绘制框内按G弹出栅格设置。单位切换：按Q在公制（mm）和英制（mil）之间切换，1mil = 0.0254mm。</font>顶层：元器件的引脚（PAD）。丝印层：外框。机械层：3D外形。</p></li><li><p><font color=red>顶层（top layer）放置引脚</font>： 点击place-pad取出焊盘，按tab编辑引脚（或焊盘）属性，设置引脚所在层级为顶层（top layer），Pad Stack中设置焊盘的形状以及长宽（焊盘应当有足够的机械强度）。利用捕获栅格距离的设置，根据具体参数放置各个焊盘。按顺序放置完所有焊盘之后，编辑-设置参考点-中心点。</p></li><li><p><font color=red>丝印层（top overlay）放置芯片外框丝印</font>：用直线画出芯片外框，用豁口标记1引脚位置。</p></li><li><p><font color=red>机械层（mechanical layer）设置3D外形</font>：放置(place) – 3D元件体，右方选项卡中identifier标明器件名称，Board side指的是板面的侧，如果选择顶层（top），则3D元件体垂直纸面向外，选择底层（Bottom）则反之。3D Model Type有四种类型，其中Extruded（柱体）、Cylinder（圆柱体）和Sphere（球体）用于建立一些简单的3D模型，Generic（通用）用于一些形式复杂的器件的导入，一般是AutoCAD中的step文件。</p></li><li><p><font color=red>通孔层（Multi-Layer）</font>：将所有层连接在一起，via就是处于这个层。</p></li></ol><h4 id="绘制schlib"><a class="markdownIt-Anchor" href="#绘制schlib"></a> 绘制SchLib</h4><p>画元器件外观以及各个引脚，复制好引脚描述，引脚的电气特性Electrical Type全部设置为Passive，因为不在AD并非电路仿真工具，AD设计只是为了导出电路板。</p><h4 id="立创商城移植pcblib与schlib节约建库时间"><a class="markdownIt-Anchor" href="#立创商城移植pcblib与schlib节约建库时间"></a> 立创商城移植PcbLib与SchLib，节约建库时间</h4><p>利用立创商城建立一些较复杂的SchLib和PcbLib，然后添加到工程中。</p><p><a href="https://www.bilibili.com/video/BV1wE411E7Lv/?from=search&amp;seid=4696785246416808838&amp;spm_id_from=333.337.0.0&amp;vd_source=723bcc95ea546f87d4985cbd117c5454">立创商城和立创EDA如何将元件库导入Altium Designer为己所用</a></p><p><a href="https://www.bilibili.com/video/BV1d44y1b7Cc/?p=3&amp;vd_source=723bcc95ea546f87d4985cbd117c5454">极简PCB绘制，立创商城白嫖原理图库和PCB库</a></p><p>操作步骤文字描述：</p><ol><li>在立创商城中搜索所需元器件，选定元器件之后点击数据手册-立即使用。</li><li>然后文件-导出Altium Designer，将所选元件的SchDoc与PcbDoc下载。</li><li>使用AD打开两个文件，对Sch文件使用Design-Make Schematic Library，生成SchLib，类似操作生成PcbLib。</li><li>进入生成的库中，将其中的元器件从左边菜单栏中复制到项目库文件的菜单栏中，至此，移植完毕。</li></ol><h3 id="原理图绘制"><a class="markdownIt-Anchor" href="#原理图绘制"></a> 原理图绘制</h3><h4 id="绘制步骤概述"><a class="markdownIt-Anchor" href="#绘制步骤概述"></a> 绘制步骤概述</h4><p>原理图绘制的四个步骤：</p><ol><li>添加元器件到原理图。</li><li>连接元器件，三个步骤：连线、网名、给网名加上示意标识。</li><li>元器件编号。</li><li>检查原理图。</li></ol><p>tips：器件按空格旋转，按X/Y镜像翻转。</p><h4 id="添加元器件"><a class="markdownIt-Anchor" href="#添加元器件"></a> 添加元器件</h4><p>在右侧菜单的“component”选项卡中，选择元器件所在库，将之拖出到SchDoc。</p><h4 id="连接元器件"><a class="markdownIt-Anchor" href="#连接元器件"></a> 连接元器件</h4><p>按照信号传输方向以及数据手册要求放置元器件。利用线和网名连接各个元器件引脚。<br />对于两条差分线，应该分别定义网名为“变量名_P”与“变量名_N”并且在两条差分线上放上差分对标示，如下图所示。这样在pcb自动生成的时候，两条差分线将会等长，使高速信号在传输过程中不发生偏差。<br />在芯片悬空的位置放置“NO ERC”标示，条理清晰，预防报错。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E5%B7%AE%E5%88%86%E7%BA%BF.png" alt="P5.4-差分线.png" /></p><h4 id="元器件编号"><a class="markdownIt-Anchor" href="#元器件编号"></a> 元器件编号</h4><p>对于有特定名称的元器件，选择直接编辑元器件的Designator。<br />对于没有特定名称的元器件，形式为 “U?”、“J?”、“C?”… …则使用自动标号，在顶部菜单栏的工具选项卡中选择“标注—原理图标注”，点击“更新更改列表”弹出更改提示框，再点击“接受更改”，验证并执行变更，完成元器件编号。</p><h4 id="检查原理图"><a class="markdownIt-Anchor" href="#检查原理图"></a> 检查原理图</h4><p>右键工程编译工程，看原理图是否出错，若没有错误则不会弹出提示框。</p><h3 id="网表的概念fpga相关"><a class="markdownIt-Anchor" href="#网表的概念fpga相关"></a> 网表的概念（FPGA相关）</h3><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E7%BD%91%E8%A1%A8%E4%BC%A0%E9%80%92%E7%9A%84%E6%B6%88%E6%81%AF.png" alt="P5.5-网表传递的消息.png" /></p><p>所谓网表，就是包含了原理图文件中所有连接关系的文字描述文件。其中器件和网络最为重要，不可或缺。<br />在AD中依次点击“设计(design)—工程网络列表(netlist for project)—protel”，右边目录出现“Generated”选项卡，内部包含一个.NET文件。</p><p>网表中的每个单元（元器件）信息用方括号表示，在网表的最前面。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E7%BD%91%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%83%E5%99%A8%E4%BB%B6%E4%BF%A1%E6%81%AF.png" alt="P5.6-网表中的元器件信息.png" /></p><p>对于人工定义的网络，网络的传递用小括号表示，第一行为网络的名称（人工定义的网名），后面的引脚标号表示了网络中连接的引脚。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E7%BD%91%E8%A1%A8%E4%B8%AD%E4%BA%BA%E5%B7%A5%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BD%91%E7%BB%9C.png" alt="P5.7-网表中人工定义的网络.png" /></p><p>对于未人工定义的网络，网络的传递依旧用小括号来表示，与人工定义的网络不同之处：网络名称为自动生成的网名，如图中NETC5_1为自动生成的网名，表示C5的第一个引脚。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E7%BD%91%E8%A1%A8%E4%B8%AD%E6%9C%AA%E4%BA%BA%E5%B7%A5%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BD%91%E7%BB%9C.png" alt="P5.8-网表中未人工定义的网络.png" /></p><p>根据网表的内容，我们可以看出引脚的名字（name）并不重要，重要的是引脚的标识符（designator），电路图只认封装和联系关系。<br />只需拿出封装库与网表文件，就可以在Cadence内设计PCB板。网表文件中包含着各器件的连接关系，不同软件之间的原理图和PCB之间的电路信息传递都通过网表来实现。</p><h3 id="pcb绘制"><a class="markdownIt-Anchor" href="#pcb绘制"></a> PCB绘制</h3><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/PCB%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="P5.9-PCB绘制流程.png" /></p><h4 id="导入原理图到pcb"><a class="markdownIt-Anchor" href="#导入原理图到pcb"></a> 导入原理图到PCB</h4><p>导入原理图到PCB时，若验证变更出错，则尝试直接执行变更。因为验证变更是把原理图生成网表进行一次检查，部分需要二次验证的逻辑无法验证。例如差分线需要验证网名对，一次验证网名必然出错，但是执行变更相当于两次验证网名，差分线得以验证。</p><h4 id="建立规则"><a class="markdownIt-Anchor" href="#建立规则"></a> 建立规则</h4><h5 id="工厂设计极限设置"><a class="markdownIt-Anchor" href="#工厂设计极限设置"></a> 工厂设计极限设置</h5><p>点击“设计—规则”。修改电气指标（Electrical）中线与线的间距（Clearance）；线路指标（Routing）中线宽（Width）、过孔参数（RoutingVias）、差分线路径参数（Differential Pairs Routing）；覆铜规则（Plane）也可能用上。</p><h5 id="叠层设计layer-stack-manager用于设计多层板"><a class="markdownIt-Anchor" href="#叠层设计layer-stack-manager用于设计多层板"></a> 叠层设计Layer Stack Manager（用于设计多层板）</h5><p>设计（Design）–层叠管理器（Layer Stack Manager）</p><p>双层PCB板结构（从上到下）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Top Overlay     （顶层丝印层）--</span><br><span class="line">Top Solder      （顶层阻焊层）--</span><br><span class="line">Top Layer       （顶层信号层）--</span><br><span class="line">Dielectric 1    （电介质层1）-- </span><br><span class="line">Bottom Layer    （底层信号层）-- </span><br><span class="line">Bottom Solder   （底层阻焊层）-- </span><br><span class="line">Bottom Overlay  （底层丝印层）</span><br></pre></td></tr></table></figure><blockquote><p>tips：电路板一般来讲只有偶数层，因为标准板型为双层板，偶数层的电路板能由多块双层电路板中间增加电介质层堆叠而成。而奇数层往往需要定制电路板，成本较高。</p></blockquote><p>叠层时注意层级的类型：<br />Internal Plane为内电层，多层板用于铺VCC铜层和GND地层，不能走信号，生产过程中出光绘胶片时出负胶片。<br />Signal layer为信号层，用于安装元器件及走线，生产过程中出光绘胶片时出正胶片，在此层出现的线与铜皮都是实际出的板子上的线路与铜皮。</p><h4 id="pcb布局"><a class="markdownIt-Anchor" href="#pcb布局"></a> PCB布局</h4><p>在PCB布局之前，视图配置(view configuration)是必要的，最小化布局过程中受到的干扰，比如隐藏一些对布局没有帮助的Layer，修改Layer的颜色。<br />按快捷键L弹出view configuration，或者点击界面右下方“Panels”按钮找到view configuration。如下图，在布局布线过程中，信号层（Top/Bottom Layer）和丝印层（Overlay）最为重要，其他的都可以隐藏。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E8%A7%86%E5%9B%BE%E9%85%8D%E7%BD%AE(view%20configuration).png" alt="P5.10-视图配置(view configuration).png" /></p><p>设置完view configuration之后，将元器件按照信号传输方向有逻辑地排列在线路板上，使得元器件之间引线短，同时打开PCB和原理图（“Window—垂直平铺”），按照连接关系布局，PCB板设计90％在于布局，10％在于布线，布局得当，布线就容易。</p><p>芯片的去耦电容应该靠近芯片的供电引脚，并且容值越小的电容应该越近。</p><h4 id="pcb布线和铺铜"><a class="markdownIt-Anchor" href="#pcb布线和铺铜"></a> PCB布线和铺铜</h4><p>PCB布线先布模拟信号线和高速信号线，因为这两者容易受干扰，高速信号线还容易干扰别的电路。在布局时就该考虑到，要让这两种线尽量短。<br />如果PCB无法布线，则需要删除并回到原理图重新修改。</p><p>在PCB中，我们常常选用一整片铜片来连接VCC网络和GND网络，可以起到降低阻抗，减少尖峰信号的作用，因此就有了铺铜操作。<br />对于电路板铺铜操作，首先需要画出铺铜的区域，右键区域铺铜，如下图。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/PCB%E9%93%BA%E9%93%9C.png" alt="P5.11-PCB铺铜.png" /></p><p>选定好铺铜之后，再选择铜皮所连接的网络，如下图</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E8%AE%BE%E7%BD%AE%E9%93%9C%E7%9A%AE%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BD%91%E7%BB%9C.png" alt="P5.12-设置铜皮所对应的网络.png" /></p><p>铺完之后需要查看网络中的点是否都连接在一起，如果有元器件没有连接，则需要重新调整铺铜区域。铺铜往往用于VCC网络和GND网络的连接。</p><p>快捷键 “数字小键盘*” 能够在电路板布线时切换层级，过孔(via)是联系Top Layer和Bottom Layer的重要PCB元件。过孔的快速放置方法：交互式布线以线路板Top Layer作为起点，然后按快捷键&quot;*&quot;切换层级，将终点放置在Bottom Layer，则会自动生成过孔(via)。前面的布局必须要得当，不然会被迫设置大量via，每个via中都会有寄生电容和电感，很可能影响电路的正常运行。</p><h4 id="规则检查"><a class="markdownIt-Anchor" href="#规则检查"></a> 规则检查</h4><p>工具(tool)–设计规则检查(Design Rule Check)–运行DRC(Run Design Rule Check)</p><p>出现错误，查看错误内容，此时的问题主要是阻焊(solder)和丝印(silk)的问题了，如下图，打开规则中的manufacturing选项，修改其中有关于silk和solder的设置。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E4%BF%AE%E6%94%B9%E9%98%BB%E7%84%8A(solder)%E5%92%8C%E4%B8%9D%E5%8D%B0(sillk)%E8%AE%BE%E7%BD%AE.png" alt="P5.13-修改阻焊(solder)和丝印(sillk)设置.png" /></p><p>如下图，阻焊层裂口(Solder Mask Sliver)表示对象之间的间距最小值，与加工厂工艺水平有关，一般设置为0mm也不会出问题。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E8%AE%BE%E7%BD%AE%E9%98%BB%E7%84%8A%E5%B1%82%E8%A3%82%E5%8F%A3(Solder%20Mask%20Sliver).png" alt="P5.14-设置阻焊层裂口(Solder Mask Sliver).png" /></p><p>如下图，焊盘与丝印层的之间的间距(Silk To Mask Clearance)不能过小也不能大，过小会导致丝印在焊盘上，焊盘是光滑的，无法丝印；过大会导致丝印层与元器件的对应关系混乱。一般设置为0.1mm。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E8%AE%BE%E7%BD%AE%E7%84%8A%E7%9B%98%E4%B8%8E%E4%B8%9D%E5%8D%B0%E5%B1%82%E7%9A%84%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E8%B7%9D(Silk%20To%20Mask%20Clearance).png" alt="P5.15-设置焊盘与丝印层的之间的间距(Silk To Mask Clearance).png" /></p><p>如下图，字符位号与位号之间，位号与芯片外框之间的距离，定义为0.1mm。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E8%AE%BE%E7%BD%AE%E4%B8%9D%E5%8D%B0%E5%B1%82%E6%96%87%E5%AD%97%E5%88%B0%E5%85%B6%E4%BB%96%E4%B8%9D%E5%8D%B0%E5%B1%82%E5%AF%B9%E8%B1%A1%E9%97%B4%E8%B7%9D.png" alt="P5.16-设置丝印层文字到其他丝印层对象间距.png" /></p><h4 id="板框大小设定对于有公版外壳的产品需要放在第一步进行"><a class="markdownIt-Anchor" href="#板框大小设定对于有公版外壳的产品需要放在第一步进行"></a> 板框大小设定（对于有公版外壳的产品需要放在第一步进行）</h4><p>对于有外壳的产品，其板框大小在外壳确定之后就已经确定了，因此可放在第一步。<br />设置板框有两种方法：</p><ol><li>在PCB界面按快捷键“1”，进入机械视图，依次点击“设计（Design）–重新定义板形状（Redefine Board Shape）”，框选出板框的范围。</li><li>在Keep-Out Layer（板框层）中画一个矩形框，在view configuration里设置只显示Keep-Out Layer，将之前画的矩形框选中，然后依次点击“设计（Design）–板子形状（Board Shape）–从选择对象中定义（Define from selected objects）”。</li></ol><p>较为推荐第二种方法。</p><h3 id="bom文件整理"><a class="markdownIt-Anchor" href="#bom文件整理"></a> BOM文件整理</h3><h4 id="利用ad生成bom表"><a class="markdownIt-Anchor" href="#利用ad生成bom表"></a> 利用AD生成BOM表</h4><p>BOM（bill of materials，材料清单）制作<br />BOM表直接从原理图中导出，因此需要将原理图中的元件名称后加上必要的标识，方便后续采购。<br />“报告（Reports）-- bill of materials”打开BOM表生成界面，生成BOM表。<br />调整BOM表格式内容，元器件中文名称、描述（包括value和footprint）、标志（丝印）和数量。贴片和插件分开。</p><h4 id="利用脚本生成bom清单推荐"><a class="markdownIt-Anchor" href="#利用脚本生成bom清单推荐"></a> 利用脚本生成BOM清单（推荐）</h4><p><a href="https://www.bilibili.com/video/BV12g411F7hJ/">视频教程：AD21生成交互式BOM文件</a></p><div style="position: relative; padding: 30% 45%;"><iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?cid=407833581&aid=505445640&page=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no"></iframe></div><p>开源脚本发布地址：<a href="https://github.com/lianlian33/InteractiveHtmlBomForAD/releases">Releases · lianlian33/InteractiveHtmlBomForAD (github.com)</a><br />下载脚本文件，到设置的“scripting system”中选择脚本目录中的.PrjScr文件导入，点击脚本文件夹中的Initialize.bat进行初始化操作，至此，脚本安装完成。<br />在AD中打开.PcbDoc文件，上方菜单栏中选择文件选项卡中的运行脚本选项，选择mainWin.js中的startWin运行。如右图中设置，点击“GenerateBom”生成BOMhtml文件。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.2/%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90BOM%E6%B8%85%E5%8D%95.png" alt="P5.17-脚本生成BOM清单.png" /></p><h3 id="打板文件的输出"><a class="markdownIt-Anchor" href="#打板文件的输出"></a> 打板文件的输出</h3><p>不涉及机密的电路板，可以直接将.PcbDoc发给厂商进行生产。<br />涉及到机密的电路板，一般先转换成Gerber文件再发给厂商，实际上厂商要进行电路板制造的话，也是需要先将PCB文件转换为Gerber文件再进行生产。</p><p><a href="https://blog.csdn.net/lin5103151/article/details/89600860">PCB加工文件—Gerber文件的导出</a></p>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.3. 实战项目一：无线门磁探测器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> 项目实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.5-利用hexo-abbrlink插件为HEXO博客文章添加永久短链</title>
      <link href="/posts/489f484e.html"/>
      <url>/posts/489f484e.html</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a class="markdownIt-Anchor" href="#引入"></a> 引入</h2><p>HEXO默认生成的博客链接格式为 “https://{domain}/year/month/day/article_name/” 如果后期需要修改博客标题，会导致原有链接失效，而且中文标题会有非常长的编码，非常不利于分享和搜索引擎收录，所以使用 hexo-abbrlink 插件为HEXO中的每一篇文章编上一个特有的 abbrlink ID ，用这个ID号来识别文章。</p><p>通过插件修改后的博客文章链接格式为 “https://{domain}/posts/abbrlink_ID.html” 明显简洁了不少。</p><p>接下来举个例子感受一下：</p><p>配置插件前的链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.magicconch.top/2023/09/01/2.3.1-%E6%97%A0%E7%BA%BF%E9%97%A8%E7%A3%81%E6%8E%A2%E6%B5%8B%E5%99%A8%E5%BC%80%E5%8F%91%E6%A6%82%E8%A6%81/</span><br></pre></td></tr></table></figure><p>配置插件后的链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.magicconch.top/posts/51745.html</span><br></pre></td></tr></table></figure><p>总而言之，使用 hexo-abbrlink 插件有以下优势：</p><ol><li>可以自由修改文章标题而原链接不失效</li><li>让博客文章链接更加美观</li><li>便于搜索引擎收录</li></ol><h2 id="操作流程"><a class="markdownIt-Anchor" href="#操作流程"></a> 操作流程</h2><h3 id="安装插件"><a class="markdownIt-Anchor" href="#安装插件"></a> 安装插件</h3><p>hexo目录下bash输入以下命令自动安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><h3 id="更改配置文件"><a class="markdownIt-Anchor" href="#更改配置文件"></a> 更改配置文件</h3><p>hexo config文件_config.yml（注意不是主题config文件）中修改以下内容</p><p>配置文件末尾添加以下字段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment">#算法： crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制： dec(default) and hex</span></span><br></pre></td></tr></table></figure><p>并将以下字段</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br></pre></td></tr></table></figure><p>用</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span>  <span class="comment"># 此处可以自己设置，也可以直接使用 :/abbrlink</span></span><br></pre></td></tr></table></figure><p>替换</p><p>最后是喜闻乐见的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>部署成功！</p><h2 id="tips"><a class="markdownIt-Anchor" href="#tips"></a> tips</h2><p>HEXO .md文件头默认格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 1.4-为Melody主题的HEXO博客添加gitalk评论区</span><br><span class="line">date: 2023-08-18 16:24:00</span><br><span class="line">categories: </span><br><span class="line">- 1. HEXO</span><br><span class="line">tags:</span><br><span class="line">- HEXO</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>安装插件后生成格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 1.4-为Melody主题的HEXO博客添加gitalk评论区</span><br><span class="line">categories:</span><br><span class="line">  - 1. HEXO</span><br><span class="line">tags:</span><br><span class="line">  - HEXO</span><br><span class="line">abbrlink: 54282</span><br><span class="line">date: 2023-08-18 16:24:00</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>只多了一个 abbrlink 字段，可以自己手动输入一个16进制数，也可以保存 .md 文件自动生成 abbrlink ID 。</p>]]></content>
      
      
      <categories>
          
          <category> 1. HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.3.1-无线门磁探测器开发概要</title>
      <link href="/posts/51745.html"/>
      <url>/posts/51745.html</url>
      
        <content type="html"><![CDATA[<h2 id="电子产品开发流程"><a class="markdownIt-Anchor" href="#电子产品开发流程"></a> 电子产品开发流程</h2><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.1/%E7%94%B5%E5%AD%90%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.webp" alt="P1-电子产品开发流程.webp" /></p><p>电子产品立项有以下要点</p><table><thead><tr><th>要点</th><th>备注</th></tr></thead><tbody><tr><td>成本评估</td><td>BOM单品成本、开发物料成本、人工成本、时间成本</td></tr><tr><td>开发周期评估（开题报告）</td><td>开发周期、开发阶段性成果要求</td></tr><tr><td>风险评估</td><td>技术风险、认证风险等</td></tr><tr><td>开发团队的组建</td><td>硬件、软件、测试、结构、UI工程师等</td></tr><tr><td>…</td><td></td></tr></tbody></table><h2 id="门磁探测器简单介绍"><a class="markdownIt-Anchor" href="#门磁探测器简单介绍"></a> 门磁探测器简单介绍</h2><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.1/%E6%97%A0%E7%BA%BF%E9%97%A8%E7%A3%81%E6%8E%A2%E6%B5%8B%E5%99%A8%E5%A4%96%E8%A7%82.png" alt="P2-无线门磁探测器外观.png" /></p><p>门磁探测器是用来探测门、窗、抽屉等是否被非法打开或移动的报警器，由门磁主体和永磁体构成。</p><p>门磁产品的分类：</p><table><thead><tr><th>类别</th><th>通讯方式</th></tr></thead><tbody><tr><td>有线门磁</td><td>485通讯, 开关信号…</td></tr><tr><td>无线门磁</td><td>ASK, FSK, 蓝牙, WIFI, NB-Iot, Lora等</td></tr><tr><td>独立门磁</td><td>现场报警提示</td></tr></tbody></table><h2 id="门磁探测器开发主要内容"><a class="markdownIt-Anchor" href="#门磁探测器开发主要内容"></a> 门磁探测器开发主要内容</h2><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.3.1/%E6%97%A0%E7%BA%BF%E9%97%A8%E7%A3%81%E9%A1%B9%E7%9B%AE%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9.webp" alt="P3-无线门磁项目主要内容.webp" /></p><h2 id="门磁探测器开发需求"><a class="markdownIt-Anchor" href="#门磁探测器开发需求"></a> 门磁探测器开发需求</h2><h3 id="产品设计说明"><a class="markdownIt-Anchor" href="#产品设计说明"></a> 产品设计说明</h3><p>门磁探测器是基于433MHz无线技术开发的安防门窗状态检测探测器，配套市场上众多品牌的安防报警主机使用。<br />产品支持开关门两种状态检测上报，支持电池低压报警。提供硬件、软件、测试等整体资料，需要配套无线主机使用，只需做简单修改即可。</p><h3 id="产品模具与外壳"><a class="markdownIt-Anchor" href="#产品模具与外壳"></a> 产品模具与外壳</h3><p>本产品的外壳选择的是基于携达科技的一款公模外壳。<a href="https://detail.1688.com/offer/41757056686.html?spm=a26352.13672862.offerlist.12.d03c497crXyeJI">购买方式</a></p><h3 id="产品要求"><a class="markdownIt-Anchor" href="#产品要求"></a> 产品要求</h3><h4 id="总体需求"><a class="markdownIt-Anchor" href="#总体需求"></a> 总体需求</h4><table><thead><tr><th>指标</th><th>参数</th></tr></thead><tbody><tr><td>成本控制</td><td>BOM成本 &lt; 5元</td></tr><tr><td>待机电流</td><td>&lt; 5 uA</td></tr><tr><td>使用寿命</td><td>2年左右</td></tr><tr><td>无线通讯距离</td><td>空旷区域, 大于120米</td></tr><tr><td>是否可以穿墙</td><td>支持</td></tr><tr><td>主要功能</td><td>开门检测、关门检测、电池低压检测</td></tr></tbody></table><h4 id="供电及电压"><a class="markdownIt-Anchor" href="#供电及电压"></a> 供电及电压</h4><table><thead><tr><th>指标</th><th>参数</th></tr></thead><tbody><tr><td>供电方式</td><td>干电池</td></tr><tr><td>型号</td><td>23A</td></tr><tr><td>供电电压</td><td>12V</td></tr><tr><td>待机电流</td><td>&lt;5uA</td></tr><tr><td>无线发射电流</td><td>&lt;15mA</td></tr></tbody></table><h4 id="无线参数"><a class="markdownIt-Anchor" href="#无线参数"></a> 无线参数</h4><table><thead><tr><th>指标</th><th>参数</th></tr></thead><tbody><tr><td>编码方式</td><td>ASK(OOK)</td></tr><tr><td>无线地址</td><td>20bit</td></tr><tr><td>功能码</td><td>4bit</td></tr><tr><td>震荡电阻</td><td>330K 可定制</td></tr><tr><td>无线发射距离</td><td>空旷区域   &gt; 120 m</td></tr><tr><td>EV1527编码</td><td>内置兼容</td></tr><tr><td>PT2262编码</td><td>需定制开发</td></tr><tr><td>发射频率</td><td>433.92MHZ（可选315MHZ,868.32MHZ)）</td></tr><tr><td>编码方式</td><td>MCU内部编码</td></tr></tbody></table><h4 id="主要功能和上报数据说明"><a class="markdownIt-Anchor" href="#主要功能和上报数据说明"></a> 主要功能和上报数据说明</h4><table><thead><tr><th>指标</th><th>支持情况</th></tr></thead><tbody><tr><td>开门数据上报</td><td>支持</td></tr><tr><td>关门数据上报</td><td>支持（可关闭）</td></tr><tr><td>电池低压数据上报</td><td>支持（可关闭）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.3. 实战项目一：无线门磁探测器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> 项目实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2.3-单片机外围电路中的重要模块</title>
      <link href="/posts/3252.html"/>
      <url>/posts/3252.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用电源电路"><a class="markdownIt-Anchor" href="#常用电源电路"></a> 常用电源电路</h2><table><thead><tr><th>参数</th><th>典型值</th></tr></thead><tbody><tr><td>常用的供电电源</td><td>AC220V, DC24V, DC12V, DC9V, DC5V</td></tr><tr><td>常用的电池</td><td>12V, 9V, 7.4V, 3.7V, 3V, 1.5V, 1.2V等</td></tr><tr><td>常用芯片供电电压</td><td>5V, 3.3V, 1.8V等</td></tr><tr><td>常见的电源芯片</td><td>LM1117-5.0 (-3.3V), HT7550(7530), LM7850, LM29302, EL1513E, LM2596</td></tr></tbody></table><p>电源设计注意事项：</p><ol><li>输入电压</li><li>输出电压</li><li>输出最大电流</li><li>输出电源纹波</li><li>其他参数</li></ol><h2 id="led驱动电路"><a class="markdownIt-Anchor" href="#led驱动电路"></a> LED驱动电路</h2><p>如P2.1所示电路为常规LED驱动电路。LED-WIFI为单片机IO口，当此IO口为低电平时，三极管工作在截止区，LED灯不亮; 反之则反之。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.3/%E5%B8%B8%E8%A7%84LED%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF.webp" alt="P2.1-常规LED驱动电路.webp" /></p><p>如P2.2所示电路为错误的LED驱动电路。将LED灯直接接在IO口上，看似能实现功能，实际上会产生大电流损坏单片机。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.3/%E9%94%99%E8%AF%AFLED%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF.webp" alt="P2.2-错误LED驱动电路.webp" /></p><h2 id="数码管检测电路"><a class="markdownIt-Anchor" href="#数码管检测电路"></a> 数码管检测电路</h2><p>led数码管（LED Segment Displays）是由多个发光二极管封装在一起<br />分类：</p><blockquote><p>共阴数码管：共阴极数码管是把所有led的阴极连接到共同接点COM</p></blockquote><blockquote><p>共阳数码管：共阳极数码管是把所有led的阳极连接到共同接点COM</p></blockquote><p><a href="http://www.fangchip.com/h-pd-90.html#pfc=%7B%22groupIds%22%3A%5B16%5D%2C%22lid%22%3A1%2C%22sc%22%3A%7B%22key%22%3A%22name%22%2C%22desc%22%3Afalse%7D%7D&amp;_jcp=3_16">数码管资料</a></p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.3/%E5%85%B1%E9%98%B3%E6%9E%81%E5%92%8C%E5%85%B1%E9%98%B4%E6%9E%81%E6%95%B0%E7%A0%81%E7%AE%A1%E5%86%85%E9%83%A8%E7%94%B5%E8%B7%AF.webp" alt="P3.1-共阳极和共阴极数码管内部电路.webp" /><br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.3/%E6%95%B0%E7%A0%81%E7%AE%A1%E5%A4%96%E5%9B%B4%E7%94%B5%E8%B7%AF.webp" alt="P3.2-数码管外围电路.webp" /></p><h2 id="蜂鸣器驱动电路"><a class="markdownIt-Anchor" href="#蜂鸣器驱动电路"></a> 蜂鸣器驱动电路</h2><p><a href="http://www.360doc.com/content/19/0416/08/441458_829110203.shtml"><strong>参考资料</strong></a></p><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><p>按照驱动原理分类，可分为有源蜂鸣器和无源蜂鸣器；<br />按照构造分类，可分为电磁式蜂鸣器和压电式蜂鸣器；<br />按照封装分类，可分为 DIP BUZZER（插针蜂鸣器）和 SMD BUZZER（贴片式蜂鸣器）；<br />按照控制电流分类，可分为直流蜂鸣器和交流蜂鸣器。</p><h3 id="压电式蜂鸣器对比电磁式蜂鸣器"><a class="markdownIt-Anchor" href="#压电式蜂鸣器对比电磁式蜂鸣器"></a> 压电式蜂鸣器对比电磁式蜂鸣器</h3><ol><li>压电式蜂鸣器通常是直流蜂鸣器，使用压电材料，为 <strong>容性元器件</strong>。压电材料受到外力产生形变时，会产生电荷；相反的，通电时，压电材料会产生形变。</li><li>电磁式蜂鸣器利用了通电导体产生磁场的特性，用一个固定的永久磁铁与通电导体产生磁力推动固定在线圈上的鼓膜，为 <strong>感性元器件</strong>。</li><li>由于两种蜂鸣器发音原理不同，压电式结构简单耐用但音调单一音色差，适用于报警器等设备。而电磁式由于音色好，所以多用于语音、音乐等设备。</li></ol><h3 id="有源蜂鸣器与无源蜂鸣器"><a class="markdownIt-Anchor" href="#有源蜂鸣器与无源蜂鸣器"></a> 有源蜂鸣器与无源蜂鸣器</h3><p>有源蜂鸣器也称为自激式蜂鸣器，元器件内部自带驱动电路，直接接上额定电源（新的蜂鸣器在标签上都有注明）即可连续发声，但声音是固定的。</p><p>无源蜂鸣器也称为他激式蜂鸣器，和电磁扬声器一样，需要接在音频输出电路中才能发声，必须使用2K-5K的方波驱动，但可以通过控制输入自由控制蜂鸣器输出。</p><p>无源蜂鸣器的主要优点是价格便宜、声音频率可控、可以与LED灯复用控制口（音频可视化）。缺点是使用上不如有源蜂鸣器方便</p><h3 id="驱动电路示例与原理"><a class="markdownIt-Anchor" href="#驱动电路示例与原理"></a> 驱动电路示例与原理</h3><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.3/%E8%9C%82%E9%B8%A3%E5%99%A8%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF.webp" alt="P4.1-蜂鸣器驱动电路.webp" /></p><p>P4.1左图是一个蜂鸣器驱动电路的示意图，通过一个驱动三极管控制蜂鸣器的声音，基极为控制端口。<br />P4.1右图才是完整的蜂鸣器驱动电路，示例是电磁式蜂鸣器，为感性元器件，所以要在其两端并联一个续流二极管D8，不然当驱动三极管突然进入截止区时蜂鸣器会产生较大的尖峰电压，从而损坏三极管或者影响电路中其他器件。<br />同样的，控制压电式蜂鸣器时，蜂鸣器两端应该并联一个电阻，消耗电容中的电荷。</p><h2 id="eeprom-flash-驱动电路"><a class="markdownIt-Anchor" href="#eeprom-flash-驱动电路"></a> EEPROM FLASH 驱动电路</h2><blockquote><p>P5.1是最常见的EEPROM芯片 24C 系列，使用IIC通讯方式</p></blockquote><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.3/24C%E7%B3%BB%E5%88%97EEPROM%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF.webp" alt="P5.1-24C系列EEPROM驱动电路.webp" /></p><blockquote><p>P5.2是最常见的FLASH芯片 25Q 系列，使用SPI通讯方式:</p></blockquote><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.3/25Q%E7%B3%BB%E5%88%97EEPROM%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF.webp" alt="P5.2-25Q系列EEPROM驱动电路.webp" /></p><h2 id="stc51-最小系统"><a class="markdownIt-Anchor" href="#stc51-最小系统"></a> STC51 最小系统</h2><p>STC51 单片机的最小系统主要包含以下四个模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">电源:       供电正常</span><br><span class="line">复位电路:   部分芯片内置</span><br><span class="line">系统时钟:   部分芯片内置，但外置晶振精度通常较高</span><br><span class="line">程序烧录：  芯片烧录接口</span><br></pre></td></tr></table></figure><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.3/STC51%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F.png" alt="P6.1-STC51最小系统.png" /></p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.3/%E5%A4%8D%E4%BD%8D%E7%94%B5%E8%B7%AF.png" alt="P6.2-复位电路.png" /></p><h2 id="stm32f1-系列最小系统"><a class="markdownIt-Anchor" href="#stm32f1-系列最小系统"></a> STM32F1 系列最小系统</h2><p>STM32F1 系列单片机最小系统与 STC51 系列类似，但其功能更强大，所有含有更多模块。</p><p><a href="https://zhuanlan.zhihu.com/p/92483993"><strong>参考资料</strong></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">电源:      供电正常 </span><br><span class="line">复位电路:  部分芯片内置</span><br><span class="line">系统时钟:  部分芯片内置，但外置晶振精度通常较高</span><br><span class="line">程序烧录:  芯片烧录接口</span><br><span class="line">其他:      BOOT0 BOOT1等</span><br></pre></td></tr></table></figure><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.3/STM32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F.webp" alt="STM32最小系统.webp" /></p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.3/STM32%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.webp" alt="STM32启动模式.webp" /></p>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.2. 单片机硬件基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2.2-电阻丨电容丨二极管丨三极管 - 基础知识</title>
      <link href="/posts/13788.html"/>
      <url>/posts/13788.html</url>
      
        <content type="html"><![CDATA[<h2 id="电阻resistor"><a class="markdownIt-Anchor" href="#电阻resistor"></a> 电阻(Resistor)</h2><p>贴片电阻的识别方法(两种):</p><p>三位：它的第一位和第二位为有效数字，第三位表示在有效数字后面所加“0”的个数．这一位不会出现字母。<br />例如：“472”表示“4700Ω”；“151”表示“150”</p><p>四位：前三位表示有效数字，第4位表示在有效数字后面所加“0”的个数。<br />例如：“2702”表示27000Ω=27kΩ</p><h2 id="电容"><a class="markdownIt-Anchor" href="#电容"></a> 电容</h2><p>电容器在调谐、旁路、耦合、<font color=red>滤波</font>等电路中起着重要的作用。<br />在直流电路中，电容器是相当于断路的。电容器是一种能够储藏电荷的元件，也是最常用的电子元件之一（通交流  隔直流）。</p><h2 id="二极管"><a class="markdownIt-Anchor" href="#二极管"></a> 二极管</h2><h3 id="判别正-负电极"><a class="markdownIt-Anchor" href="#判别正-负电极"></a> 判别正、负电极</h3><ol><li>观察外壳上的符号标记。通常在二极管的外壳上标有二极管的符号，带有三角形箭头的一端为正极，另一端是负极。</li><li>观察外壳上的色点。在点接触二极管的外壳上，通常标有极性色点(白色或红色)。一般标<font color=red>有色点的一端即为正极</font>。还有的二极管上标有色环，<font color=red>带色环的一端则为负极</font>。</li><li>以阻值较小的一次测量为准，黑表笔所接的一端为正极，红表笔所接的一端则为负极。</li><li>观察二极管外壳，带有银色带一端为负极。</li></ol><h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3><p>发光二极管、光电二极管、稳压管、面接触型二极管、点接触型二极管…<br />（肖特基二极管）</p><h3 id="常规二极管原理"><a class="markdownIt-Anchor" href="#常规二极管原理"></a> 常规二极管原理</h3><p>二极管由P(positive)型半导体和N(negative)型半导体接触组成，由P型流向N型的电流是<font color=red>正向电流</font>。</p><ol><li>P型半导体：半导体（硅或者锗）掺入3价硼原子，半导体最外层有4个电子，而磷原子最外层有3个电子，掺杂之后为了形成最外层8个电子的稳定结构，少了一个自由电子，称为空穴。</li><li>N型半导体：半导体（硅或者锗）掺入5价磷原子，半导体最外层有4个电子，而磷原子最外层有5个电子，掺杂之后为了形成最外层8个电子的稳定结构，多出来一个自由电子。</li></ol><p><strong>注意</strong>：P型半导体和N型半导体本身呈现电中性。</p><p>如P3.1所示，P型半导体和N型半导体接触后，N区自由电子向P区扩散以填充空穴。N区那部分PN结失去电子呈现正电，P区那部分PN结得到电子呈现负电，PN结内部产生一个从N区指向P区的电场，称为内建电场。<br />正所谓相反相成之谓道，电子的扩散运动造就内建电场的同时，内建电场也在阻止扩散运动的发生。内建电场能将电子从P区运送到N区，这恰恰与电子扩散运动的方向相反。同样的，当内建电场被外加电场增强时，就需要有更强的扩散运动与之平衡，参与内部扩散运动的电子也会随之增多，PN结变厚。<br />扩散运动和内建电场相互对抗相互成就，在接触面附近产生了一个稳定的PN结，看似是静止的运动，实则是运动的静止。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.2/PN%E7%BB%93%E5%8E%9F%E7%90%86.webp" alt="P3.1-PN结原理.webp" /></p><p>外接电源加正向电压时，内建电场与外加电场方向相反，内建电场被削弱，PN结势垒被逐渐打破，PN结变窄，促进扩散运动继续进行，二极管导通。<br />外接电源加反向电压时，内建电场与外加电场方向相同，内建电场被加强，PN结势垒被逐渐加强，PN结变宽，进一步阻碍扩散运动，二极管断路。</p><h3 id="肖特基二极管原理及其优缺点"><a class="markdownIt-Anchor" href="#肖特基二极管原理及其优缺点"></a> 肖特基二极管原理及其优缺点</h3><h4 id="前情提要"><a class="markdownIt-Anchor" href="#前情提要"></a> 前情提要</h4><p>反向恢复电流指的是二极管两端加反向电压时产生的一个微小且短暂的反向电流。在上面常规二极管原理中提到过内建电场被外加电场增强时，PN结变厚以重建平衡，就在PN结变厚的过程中，得有少量的负电荷从N区转移到P区，这部分负电荷从N区经由外部电路流经外加电源与负载转移到P区，产生一个短暂的反向电流。</p><p>而普通二极管的反向恢复电流持续时间相对较长，在高频电路中这是非常致命的缺点，会造成非常严重的失真。肖特基二极管应运而生，肖特基二极管就是为了解决电路高频作业下普通二极管造成结果失真的问题而被发明出来的。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.2/%E6%99%AE%E9%80%9A%E4%BA%8C%E6%9E%81%E7%AE%A1%E5%92%8C%E8%82%96%E7%89%B9%E5%9F%BA%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E5%8F%8D%E5%90%91%E6%81%A2%E5%A4%8D%E6%97%B6%E9%97%B4.webp" alt="P3.2-普通二极管和肖特基二极管的反向恢复时间.webp" /></p><h4 id="肖特基二极管原理"><a class="markdownIt-Anchor" href="#肖特基二极管原理"></a> 肖特基二极管原理</h4><p>肖特基二极管阴极为N型半导体，阳极为金属。N型半导体中自由电子浓度高，金属中自由电子浓度低，则N型半导体中的电子向金属中扩散，N型半导体失去电子形成一层肖特基势垒。原理与常规二极管差不多。<br />关键在于为什么肖特基二极管反向恢复时间短？原因很简单，因为肖特基二极管的结电容更小。<br />为什么叫结电容呢？因为常规二极管的PN结也好，肖特基二极管的肖特基结也好，在微观上看就像是一个平行板电容器，也就可以等效理解为电容，也就有了结电容的概念。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.2/%E8%82%96%E7%89%B9%E5%9F%BA%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%BB%93%E6%9E%84%E5%9B%BE.webp" alt="P3.3-肖特基二极管结构图.webp" /></p><h4 id="肖特基二极管的优缺点"><a class="markdownIt-Anchor" href="#肖特基二极管的优缺点"></a> 肖特基二极管的优缺点</h4><p>肖特基二极管的最大特点是正向压降小，反向恢复时间短。肖特基二极管的开启电压低，电荷储存效应（结电容）小，适于<font color=red>高频工作</font>。同样的电流情况下，它的正向压降要比普通二极管小许多。还具有损耗小、噪声低、检波灵敏度高、稳定可靠等特点，在微波通信和雷达中用于混频、检波、调制、倍频以及超高速开关、低噪声放大等。</p><p>肖特基二极管的优点：</p><ol><li>肖特基二极管正向导通压降(0.3 ~ 0.5V)比普通二极管(0.5 ~ 0.7V)低，所以<font color=red>低功耗</font>。</li><li>肖特基二极管反向恢复时间(10ns)比普通二极管(2μs)短，所以<font color=red>工作频率更高</font>。</li><li>肖特基二极管比普通的二极管<font color=red>通过的电流强</font>。</li><li>肖特基二极管比普通二极管的<font color=red>结电容小</font>。</li><li>肖特基二极管<font color=red>可以通过高频电流</font>。</li></ol><p>但是肖特基二极管也有明显的缺点：</p><ol><li><font color=red>造价相对较贵</font>，对于成本敏感型的嵌入式设备来说这就是最大的缺点，所以能用常规二极管就用常规二极管。</li><li>因为肖特基势垒比较薄，所以<font color=red>反向耐压比较低</font>，只有不到200V，击穿后将直接烧毁。而常规二极管的耐压可以轻松达到1000V以上。</li><li>还是因为肖特基势垒较薄，所以<font color=red>反向漏电流会比常规二极管大很多</font>。肖特基二极管反向漏电流典型值500μA，而常规二极管反向漏电流典型值仅有5μA。</li></ol><h2 id="三极管"><a class="markdownIt-Anchor" href="#三极管"></a> 三极管</h2><h3 id="三极管的概念"><a class="markdownIt-Anchor" href="#三极管的概念"></a> 三极管的概念</h3><p>三极管，全称应为半导体三极管，也称双极型晶体管、晶体三极管，是一种控制电流的半导体器件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三极管的作用是把微弱信号放大成幅度值较大的电信号，也用作无触点开关。</span><br></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/tardis/zm/art/53040143?source_id=1003"><strong>参考资料1</strong></a> <a href="https://cloud.tencent.com/developer/article/2113271"><strong>参考资料2</strong></a> <a href="https://blog.csdn.net/ybhuangfugui/article/details/107373558"><strong>参考资料3</strong></a></p><h3 id="三极管的结构"><a class="markdownIt-Anchor" href="#三极管的结构"></a> 三极管的结构</h3><p>三极管的结构简单来说是在一个硅（或锗）片上生成三个杂质半导体区域，一个P区（或N区）夹在两个N区（或P区）中间。所以三极管一般分为NPN型或PNP型，材质分为硅管或锗管。<br />从三个杂质半导体区域各引出一个电极分别叫发射极(Emitter)、集电极(Collector)、基极(Base)，相对应的杂质区域分布称为发射区、集电区、基区。三个区域形成两个PN结，发射区与基区间的PN结称为发射结，集电区和基区间的PN结称为集电结。</p><p>P4.1是两种类型三极管的概念图，其中发射极上的箭头表示发射结加正偏电压时，发射极的电流方向。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.2/NPN%E5%92%8CPNP%E5%9E%8B%E4%B8%89%E6%9E%81%E7%AE%A1%E5%BE%AE%E8%A7%82%E6%9E%84%E9%80%A0.jpg" alt="P4.1-NPN和PNP型三极管微观构造.jpg" /></p><p>由于二极管由一个PN结组成，为便于理解可以将三极管看作为两个二极管串联，如P4.2，但是增加基区电流显然不能使三极管导通，所以并不完全等价。<br />在正确的理解中，<font color=red><strong>三极管其实是两个靠得很近的二极管串联，这二极管之间的距离就是基区宽度(典型值2微米)，这个宽度必须远小于基区少子的扩散距离(典型值30微米)，这也是三极管导通的关键所在</strong></font>。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.2/%E4%B8%89%E6%9E%81%E7%AE%A1%E7%AD%89%E6%95%88%E7%94%B5%E8%B7%AF.jpg" alt="P4.2-三极管等效电路.jpg" /></p><p>以下是两种三极管的符号，接下来的分析将围绕NPN型三极管展开，PNP型三极管原理与其一致。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.2/NPN%E5%92%8CPNP%E5%9E%8B%E4%B8%89%E6%9E%81%E7%AE%A1%E7%AC%A6%E5%8F%B7.webp" alt="P4.3-NPN和PNP型三极管符号.webp" /></p><h3 id="三极管的作用"><a class="markdownIt-Anchor" href="#三极管的作用"></a> 三极管的作用</h3><ol><li>电流放大</li><li>开关</li></ol><p>对于NPN型，基极高电平（基级b电势比发射e极高0.7V）导通；<br />对于PNP型，基极低电平（发射极e电势比基级b高0.7V）导通。<br />三极管工作在饱和区通常为开关作用，三极管工作在放大区通常为放大作用。</p><p>对于NPN型三极管来说：<br />基级b电压较小时，工作于截止状态；<br />基级b电压比发射极e电压高0.7V时，工作于放大状态，集电极c电流为基级b电流的β倍；<br />当基级电流较大时，三极管工作于饱和状态，集电极与发射极之间的压降极小，通过二极管的电流由集电极电阻决定，若集电极不加电阻，三极管极有可能过流烧毁。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.2/%E4%B8%89%E6%9E%81%E7%AE%A1%E6%88%AA%E6%AD%A2%E5%8C%BA%E3%80%81%E9%A5%B1%E5%92%8C%E5%8C%BA%E3%80%81%E6%94%BE%E5%A4%A7%E5%8C%BA%E5%92%8C%E5%87%BB%E7%A9%BF%E5%8C%BA.jpg" alt="P4.4-三极管截止区、饱和区、放大区和击穿区.jpg" /></p><h3 id="三极管导通原理的微观分析"><a class="markdownIt-Anchor" href="#三极管导通原理的微观分析"></a> 三极管导通原理的微观分析</h3><p><a href="https://www.zhihu.com/question/36475338/answer/1786789671"><strong>参考资料4</strong></a> <a href="https://www.zhihu.com/question/36475338/answer/1574671956"><strong>参考资料5</strong></a></p><p>上面“三极管结构”中红色加粗字道出了三极管的本质，其工作原理涉及到了半导体中电子和空穴的运动。当对三极管施加适当的电压时，发射极和基极之间的电子（在NPN型）或空穴（在PNP型）会被推动到基极中。然后，由于基极很薄并且掺杂程度较低，大部分电子（或空穴）会穿过基极并达到集电极，从而形成电流。通过改变基极和发射极之间的电压，可以控制集电极和发射极之间的电流，实现放大或开关的功能。</p><p>需要注意的是，三极管的工作需要适当的偏置电压。对于NPN型三极管，基极-发射极需要正向偏置（基极电压高于发射极电压），基极-集电极需要反向偏置（基极电压低于集电极电压）。对于PNP型三极管，偏置条件是相反的。</p><h3 id="三极管导通原理的直观理解"><a class="markdownIt-Anchor" href="#三极管导通原理的直观理解"></a> 三极管导通原理的直观理解</h3><p>P4.5是NPN三极管导通的直观图解，绿色的箭头是基极电流，绿色小水流推动杠杆打开阀门，允许较大的蓝色水流通过阀门。增大绿色的水流就能间接增大蓝色的水流<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.2/%E4%B8%89%E6%9E%81%E7%AE%A1%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A31.png" alt="P4.5-三极管直观图解1.png" /></p><p>如图P4.6，当基级电流较大(即绿色小水流较大)时，三极管工作于饱和区，集电极与发射极之间的压降极小(阀门完全打开)，通过二极管的电流由集电极电阻决定，若集电极不加电阻R(限流阀门)，三极管极有可能过流烧毁。<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/2.2.2/%E4%B8%89%E6%9E%81%E7%AE%A1%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A32.png" alt="P4.6-三极管直观图解2.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.2. 单片机硬件基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2.1-交流电丨直流电</title>
      <link href="/posts/9864.html"/>
      <url>/posts/9864.html</url>
      
        <content type="html"><![CDATA[<h2 id="交流电alternating-current-简称ac"><a class="markdownIt-Anchor" href="#交流电alternating-current-简称ac"></a> 交流电(Alternating Current, 简称AC)</h2><p>家用单相交流电，工业用三相交流电，每一相有效值都为220V，峰值为311V，震荡频率为50hz，每两相之间的相位差为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>π</mi><mn>3</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{π}{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。</p><h2 id="直流电direct-current简称dc"><a class="markdownIt-Anchor" href="#直流电direct-current简称dc"></a> 直流电(Direct Current,简称DC)</h2><p>电子产品中大多数为弱电，且为直流电。锂电池，输出电压3.7V。</p><p>一般不会自己设计电源模块，直接购买合适的成品模块更节约成本。</p><p>直流电与交流电的关系:<br />在电源正常工作期间，<strong>恒定直流电</strong> 的电压大小和方向都不随时间的变化而变化，比如干电池。<br />在电源正常工作期间，<strong>脉动直流电</strong> 的电压方向不变，但大小随时间变化。比如：50Hz的交流电经过二极管整流后得到的就是典型脉动直流电，半波整流得到的是50Hz的脉动直流电，如果是全波或桥式整流得到的就是100Hz的脉动直流电，它们只有经过滤波（用电感或电容）以后才变成平滑直流电，当然其中仍存在脉动成分（称纹波系数），大小视滤波电路的滤波效果。</p>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.2. 单片机硬件基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.2.7-C语言数组和多维数组的定义与赋值以及code、const关键字的使用</title>
      <link href="/posts/60885.html"/>
      <url>/posts/60885.html</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2><h3 id="数组的定义"><a class="markdownIt-Anchor" href="#数组的定义"></a> 数组的定义</h3><p>指存储一个固定大小的、类型相同的顺序集合。数组用来存储一组类型相同的变量。</p><h3 id="数组的语法结构"><a class="markdownIt-Anchor" href="#数组的语法结构"></a> 数组的语法结构</h3><p>数组定义语句的基本结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datatype arrayName[length];</span><br></pre></td></tr></table></figure><p>各部分定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">datatype    // 数据类型</span><br><span class="line">arrayName   // 数组名称</span><br><span class="line">length      // 数组长度，不能为变量</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> l602Dat[<span class="number">16</span>];</span><br></pre></td></tr></table></figure><h3 id="定义与初始化数组的方法"><a class="markdownIt-Anchor" href="#定义与初始化数组的方法"></a> 定义与初始化数组的方法</h3><p>方法1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> unm[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> unm[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure><p>在单片机程序中还有最常见的一种定义，是keil特有的关键字，对数组进行了修饰。</p><p>例：char <font color=red>code</font> str[7]=”LCD1602”;</p><p>加了code之后，变量存储到ROM FLASH中；若没有code，则变量存储到RAM中。</p><p>变量存储在ROM和RAM的区别：写入到ROM中的变量不可在程序运行过程中发生改变，而存放在RAM中的变量可以随着程序的运行不断改变。</p><p>由于单片机追求低成本、低功耗。而RAM相比于ROM更加昂贵，也更耗电。为了节约成本，降低耗电量，大多数时候会考虑将程序运行过程中不会发生变动的变量写入到ROM中。</p><p><font color=red>注</font>：<strong>在keil MDK(stm32)中，需要用const代替code。</strong></p><p>在硬件层面上也很好理解，在<a href="https://magic989.github.io/2023/08/18/2.1.1.1-%E5%8D%95%E7%89%87%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3/#%E5%8D%95%E7%89%87%E6%9C%BA%E8%B5%84%E6%BA%90%E6%9C%89%E5%93%AA%E4%BA%9B">单片机资源</a>中，flash ROM是代码(code)所在的空间，而程序代码空间毋庸置疑是不可以随意更改的，将这部分变量存储到代码空间不仅提高了程序可读性还有节约成本和降低功耗的作用。</p><h3 id="数组的赋值"><a class="markdownIt-Anchor" href="#数组的赋值"></a> 数组的赋值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> unm[<span class="number">10</span>];</span><br><span class="line">unm[<span class="number">5</span>] = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><h3 id="数组的存储结构"><a class="markdownIt-Anchor" href="#数组的存储结构"></a> 数组的存储结构</h3><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.1.2.7/%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.webp" alt="数组的存储结构" /></p><h2 id="c语言多维数组定义与赋值"><a class="markdownIt-Anchor" href="#c语言多维数组定义与赋值"></a> C语言多维数组定义与赋值</h2><p>多维数组定义语句的语法结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType arrayName[length1][length2][length3]..;</span><br></pre></td></tr></table></figure><p>各部分定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">datatype    // 数据类型</span><br><span class="line">arrayName   // 数组名</span><br><span class="line">length1     // 第一维下标的长度</span><br><span class="line">length2     // 第二维下标的长度</span><br><span class="line">length3     // 第三维下标的长度</span><br></pre></td></tr></table></figure><p>三维数组实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Dat2[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;,&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>在n维数组unsigned char Data4[a_1][a_2][a_3]…[a_n]中，[a_1]是最高层的一维，[a_n]是最低层的一维。[a_n]的这一维度中仅有数字，而[a_1]的这一维中却包含着其他维度。</p>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.1. C语言基础 </category>
          
          <category> 2.1.2. C语言基本语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.2.6-C语言条件预编译命令(#if-#ifdef-#ifndef)</title>
      <link href="/posts/43750.html"/>
      <url>/posts/43750.html</url>
      
        <content type="html"><![CDATA[<p>条件编译命令最主要还是在工程头文件中使用，主要是是属于硬件层的代码。</p><h2 id="if语句的语法结构"><a class="markdownIt-Anchor" href="#if语句的语法结构"></a> #if语句的语法结构</h2><p><strong>语法结构：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 表达式1</span></span><br><span class="line">    <span class="comment">// 程序代码块1</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 表达式2</span></span><br><span class="line">    <span class="comment">// 程序代码块2</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 表达式3</span></span><br><span class="line">    <span class="comment">// 程序代码块3</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 程序代码块4</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><font color=red><em>注意</em></font>：<strong>表达式必须为一个整数型常量</strong></p><h3 id="if-表达式1"><a class="markdownIt-Anchor" href="#if-表达式1"></a> #if 表达式1</h3><p>若表达式1为真，则执行程序代码1；若为假，则不执行代码1 ，同时跳转到elif，去判断表达式2是否为真。若没有#elif，直接跳转到#else。若没有#else，直接跳转到#endif。</p><h3 id="elif-表达式2"><a class="markdownIt-Anchor" href="#elif-表达式2"></a> #elif 表达式2</h3><p>若#if条件判断为假，则跳转到本语句，需要判断表达式2是否为真，若为真，则执行程序代码块2；若为假，则跳转到下面的语句继续判断。</p><h3 id="else"><a class="markdownIt-Anchor" href="#else"></a> #else</h3><p>若以上的表达式皆假，则执行#else包含的程序代码块。</p><h3 id="endif"><a class="markdownIt-Anchor" href="#endif"></a> #endif</h3><p>和#if是配套使用的，不能省略。</p><h3 id="if-elif-else-endif代码示例"><a class="markdownIt-Anchor" href="#if-elif-else-endif代码示例"></a> (#if-#elif-#else-#endif)代码示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPTION 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OPTION == 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Option 1 is selected.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> OPTION == 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Option 2 is selected.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> OPTION == 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Option 3 is selected.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No valid option is selected.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，#define OPTION 2 定义了一个名为 OPTION 的预处理宏，并将其设置为 2。然后，使用 #if、#elif 和 #else 来根据不同的选项编译不同的代码块。</p><p>根据 OPTION 的值，编译器会选择性地编译对应的代码块。在这个例子中，OPTION 的值是 2，所以编译器会编译 “Option 2 is selected.\n” 这行代码。</p><p>这个例子展示了如何使用条件预编译指令来在不同条件下编译不同的代码，从而实现灵活的代码控制。</p><h2 id="ifdef语句的语法结构"><a class="markdownIt-Anchor" href="#ifdef语句的语法结构"></a> #ifdef语句的语法结构</h2><p><strong>语法结构：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 表达式</span></span><br><span class="line">    <span class="comment">// 程序代码块1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 程序代码块2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="ifdef-表达式"><a class="markdownIt-Anchor" href="#ifdef-表达式"></a> #ifdef 表达式</h3><p>表达式必须是一个宏定义变量。例如：#define NUM<br />如果表达式是宏定义的时候，则执行程序代码块1，否则跳转到#else所包含的程序代码块2。如果没有#else，则直接跳转到#endif。</p><h3 id="else-2"><a class="markdownIt-Anchor" href="#else-2"></a> #else</h3><p>可以有，也可以省略。<br />若#else存在且#ifdef后的表达式不是宏定义时，执行程序代码块2。</p><h3 id="endif-2"><a class="markdownIt-Anchor" href="#endif-2"></a> #endif</h3><p>和#ifdef是配套使用的，不能省略。</p><h3 id="ifdef-else-endif代码示例"><a class="markdownIt-Anchor" href="#ifdef-else-endif代码示例"></a> (#ifdef-#else-#endif)代码示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG  <span class="comment">// 注释掉这一行可以看到不同的输出</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug mode is enabled.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug mode is not enabled.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，#ifdef DEBUG 检查是否定义了名为 DEBUG 的预处理宏。由于我们在代码中定义了 #define DEBUG，所以编译器会编译位于 #ifdef 和 #else 之间的代码块，输出 “Debug mode is enabled.”。如果注释掉 #define DEBUG 这一行，编译器将会编译 #else 后的代码块，输出 “Debug mode is not enabled.”。</p><p>这个用法可以在编写调试相关代码时非常有用，可以根据是否启用了调试模式来选择性地输出调试信息。</p><h2 id="ifndef语句的语法结构"><a class="markdownIt-Anchor" href="#ifndef语句的语法结构"></a> #ifndef语句的语法结构</h2><p><strong>语法结构：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> 表达式</span></span><br><span class="line">    <span class="comment">// 程序代码块1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 程序代码块2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>使用方法：</strong></p><p>与#ifdef语句作用类似，也是对宏定义作用。区别是#ifndef后的表达式不是宏定义时，才执行程序代码块1，与#ifdef语句恰恰相反。</p>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.1. C语言基础 </category>
          
          <category> 2.1.2. C语言基本语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.2.5-C语言#include-sfr-sbit关键字用法</title>
      <link href="/posts/27110.html"/>
      <url>/posts/27110.html</url>
      
        <content type="html"><![CDATA[<h2 id="include关键字用法"><a class="markdownIt-Anchor" href="#include关键字用法"></a> include关键字用法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>            <span class="comment">// 包含一个源代码文件的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;文件名&gt;</span>   <span class="comment">// 如果需要包含标准库头文件或者实现版本所提供的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “文件名”   <span class="comment">// 如果需要包含针对程序所开发的源文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “myfile.h”</span></span><br></pre></td></tr></table></figure><p>使用尖括号&lt; &gt;和双引号&quot; &quot;的区别在于头文件的搜索路径不同：</p><blockquote><p>使用尖括号&lt; &gt;，编译器会到系统路径下查找头文件；<br />使用双引号&quot; &quot;，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。</p></blockquote><p>系统路径：在开发软件的INC文件夹中<br />tip：双引号&quot; “比尖括号&lt; &gt;功能更加强大，可以导入工程中的其他函数，但是一般来讲我们会使用”&quot;引用自己的函数，而用&lt;&gt;引用官方库函数，提升代码可读性。</p><h2 id="sfr关键字用法特殊功能寄存器sfr"><a class="markdownIt-Anchor" href="#sfr关键字用法特殊功能寄存器sfr"></a> sfr关键字用法（特殊功能寄存器sfr）</h2><p>写程序的过程就是对特殊功能寄存器赋值，sfr 定义特殊功能寄存器中的字节。类似于C语言中的宏定义，对选定字节地址进行某特殊功能的命名。<br />sfr将单片机所有的字节寄存器的字节地址在头文件中定义了，一个地址表示了多个位，这将Keil与单片机的寄存器关联起来。<br />这一般是单片机厂商就已经编写好的，他们在.h中将硬件层的寄存器地址与寄存器缩写关联起来，便于进一步开发。</p><p>格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfr 功能命名 = 地址（位地址首位）</span><br></pre></td></tr></table></figure><h2 id="sbit关键字用法"><a class="markdownIt-Anchor" href="#sbit关键字用法"></a> sbit关键字用法</h2><p>sbit 用于特殊功能寄存器中可位寻址的位地址。类似于C语言中的宏定义，对选定位地址进行某特殊功能的命名。<br />一般也由单片机厂商在.h文件中编写好。</p><p>格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbit 功能命名 = 位地址</span><br></pre></td></tr></table></figure><p>sfr针对字节，sbit针对位，以下是官方.h文件节选，用于体会两者用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内核特殊功能寄存器        // 复位值   描述</span></span><br><span class="line">sfr ACC         =   <span class="number">0xE0</span>;   <span class="comment">//0000,0000 累加器Accumulator</span></span><br><span class="line">sfr B           =   <span class="number">0xF0</span>;   <span class="comment">//0000,0000 B寄存器</span></span><br><span class="line">sfr PSW         =   <span class="number">0xD0</span>;   <span class="comment">//0000,0000 程序状态字</span></span><br><span class="line">sbit CY         =   PSW^<span class="number">7</span>;</span><br><span class="line">sbit AC         =   PSW^<span class="number">6</span>;</span><br><span class="line">sbit F0         =   PSW^<span class="number">5</span>;</span><br><span class="line">sbit RS1        =   PSW^<span class="number">4</span>;</span><br><span class="line">sbit RS0        =   PSW^<span class="number">3</span>;</span><br><span class="line">sbit OV         =   PSW^<span class="number">2</span>;</span><br><span class="line">sbit F1         =   PSW^<span class="number">1</span>;</span><br><span class="line">sbit P          =   PSW^<span class="number">0</span>;</span><br><span class="line">sfr SP          =   <span class="number">0x81</span>;   <span class="comment">//0000,0111 堆栈指针</span></span><br><span class="line">sfr DPL         =   <span class="number">0x82</span>;   <span class="comment">//0000,0000 数据指针低字节</span></span><br><span class="line">sfr DPH         =   <span class="number">0x83</span>;   <span class="comment">//0000,0000 数据指针高字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//I/O 口特殊功能寄存器</span></span><br><span class="line">sfr P0          =   <span class="number">0x80</span>;   <span class="comment">//1111,1111 端口0</span></span><br><span class="line">sbit P00        =   P0^<span class="number">0</span>;</span><br><span class="line">sbit P01        =   P0^<span class="number">1</span>;</span><br><span class="line">sbit P02        =   P0^<span class="number">2</span>;</span><br><span class="line">sbit P03        =   P0^<span class="number">3</span>;</span><br><span class="line">sbit P04        =   P0^<span class="number">4</span>;</span><br><span class="line">sbit P05        =   P0^<span class="number">5</span>;</span><br><span class="line">sbit P06        =   P0^<span class="number">6</span>;</span><br><span class="line">sbit P07        =   P0^<span class="number">7</span>;</span><br><span class="line">sfr P1          =   <span class="number">0x90</span>;   <span class="comment">//1111,1111 端口1</span></span><br><span class="line">sbit P10        =   P1^<span class="number">0</span>;</span><br><span class="line">sbit P11        =   P1^<span class="number">1</span>;</span><br><span class="line">sbit P12        =   P1^<span class="number">2</span>;</span><br><span class="line">sbit P13        =   P1^<span class="number">3</span>;</span><br><span class="line">sbit P14        =   P1^<span class="number">4</span>;</span><br><span class="line">sbit P15        =   P1^<span class="number">5</span>;</span><br><span class="line">sbit P16        =   P1^<span class="number">6</span>;</span><br><span class="line">sbit P17        =   P1^<span class="number">7</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.1. C语言基础 </category>
          
          <category> 2.1.2. C语言基本语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.2.4-C语言函数的定义及调用</title>
      <link href="/posts/36944.html"/>
      <url>/posts/36944.html</url>
      
        <content type="html"><![CDATA[<h2 id="c语言函数的定义及调用"><a class="markdownIt-Anchor" href="#c语言函数的定义及调用"></a> C语言函数的定义及调用</h2><p>函数语法结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回参数变量类型 函数名（参数声明）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回参数变量类型：char/unsigned char/int/unsigned int/float/double/…<br />定义主函数不要使用void，要用int，最后加上return 0。<br />函数名：英文字母或者下划线开头，可由英文字母、下划线和数字组成。<br />参数声明：可以说多个参数，也可以是无参数（void）</p><p>例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay_1ms</span><span class="params">(<span class="type">void</span>)</span>    <span class="comment">// 简单的延时函数，但因为没有指定单片机型号，所以i的大小并不准确</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    i = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readkey</span><span class="params">(<span class="type">void</span>)</span>   <span class="comment">// int函数示例</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> KeyValue;</span><br><span class="line">    <span class="keyword">return</span> KeyValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> sec)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sec;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay_1ms();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例4：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">DelaySec</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> sec)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sec;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay_1ms();</span><br><span class="line">    &#125;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.1. C语言基础 </category>
          
          <category> 2.1.2. C语言基本语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.2.3-C语言中常见语句的用法以及流程图的绘制</title>
      <link href="/posts/48231.html"/>
      <url>/posts/48231.html</url>
      
        <content type="html"><![CDATA[<h2 id="常见语句的用法"><a class="markdownIt-Anchor" href="#常见语句的用法"></a> 常见语句的用法</h2><h3 id="c语言if语句格式用法"><a class="markdownIt-Anchor" href="#c语言if语句格式用法"></a> C语言if语句格式用法</h3><p><strong>例1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式成立      -&gt;  为真 1  -&gt;  可运行语句1<br />条件表达式不成立    -&gt;  为假 0  -&gt;  不能运行语句1</p><p><strong>例2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用实例：实现门磁开门检测</p><h3 id="c语言while语句用法"><a class="markdownIt-Anchor" href="#c语言while语句用法"></a> C语言while语句用法</h3><h4 id="while语句格式1先判断再执行"><a class="markdownIt-Anchor" href="#while语句格式1先判断再执行"></a> while语句格式1（先判断再执行）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（表达式）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句1</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>基本规则:   表达式如果成立    -&gt;  为真 1  -&gt;  执行语句1。</p><p>通常用法:   表达式如果成立    -&gt;  为真 1  -&gt;  一直循环：while（1）<br />用于单片机的任务轮询，在语句1中加入需要调用的任务列表（即任务函数），那么单片机就会轮流运行任务。</p><h4 id="while语句格式2先执行再判断"><a class="markdownIt-Anchor" href="#while语句格式2先执行再判断"></a> while语句格式2（先执行再判断）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 语句1</span></span><br><span class="line">&#125;<span class="keyword">while</span>（表达式）</span><br></pre></td></tr></table></figure><p><strong>运行规则：</strong></p><ol><li>先执行 语句1；</li><li>再去判断表达式是否成立，如果成立，继续执行语句1；否则跳出 while 语句，继续执行下面的语句。</li></ol><h3 id="c语言switch语句用法"><a class="markdownIt-Anchor" href="#c语言switch语句用法"></a> C语言switch语句用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>：</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//语句1；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>；</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">2</span>：</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 语句2；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>；</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 语句n；  //一般为错误提示语，变量不等于以上列出的所有常量。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量t：必须为一个变量。<br />当switch后的变量与case后的变量相等，则运行对应的代码。</p><h3 id="c语言for语句用法"><a class="markdownIt-Anchor" href="#c语言for语句用法"></a> C语言for语句用法</h3><p><strong>语法结构：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 中间循环体；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表达式序号</th><th>表达式类型</th><th>运行方式</th></tr></thead><tbody><tr><td>表达式1</td><td>单次表达式</td><td>for循环开始前运行一次(赋予变量初值)</td></tr><tr><td>表达式2</td><td>条件表达式(*)</td><td>如果该语句（判断语句）为真，则执行表达式3</td></tr><tr><td>表达式3</td><td>末尾循环体</td><td>（多半为i<ins>或者</ins>i）如果表达式3中为i++，则先执行中间循环体再自增；反之则反之</td></tr></tbody></table><p><strong>以一个简单的延时函数为例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_1s</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        delay_100ms();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c语言break-continue-goto语句用法"><a class="markdownIt-Anchor" href="#c语言break-continue-goto语句用法"></a> C语言break、continue、goto语句用法</h3><p>break；语句用于do while、for、while循环语句中时，可使程序终止循环，跳出循环（永久终止循环）<br />continue：语句用于do while、for、while循环语句中时，可停止本次循环，不跳出循环语句，重新开始新的循环（终止本次循环）</p><p>goto(一般不使用，会使流程图极其复杂)：又叫做无条件转移语句，在程序中加入一个标签，然后goto 标签，程序运行到此条之后跳转到标签所在位置。既可以向前跳转，又可以向后跳转。</p><h2 id="流程图的绘制"><a class="markdownIt-Anchor" href="#流程图的绘制"></a> 流程图的绘制</h2><h3 id="结构化流程图"><a class="markdownIt-Anchor" href="#结构化流程图"></a> 结构化流程图</h3><p>C语音中有三种基本结构：顺序、选择、循环（禁止使用goto，goto会使后期维护成本大幅度增加）</p><p>如果希望用流程图描绘C语音程序，流程图必须由这三种基本结构构成，称为结构化流程图。结构化流程图有以下4个优越之处：<br />1.只有一个入口。<br />2.只有一个出口。<br />3.结构内的每一部分都有机会被执行到。<br />4.结构内不存在死循环。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.1.2.3/%E7%BB%93%E6%9E%84%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.webp" alt="结构化流程图的三种基本结构" /></p><h3 id="n-s流程图不常用"><a class="markdownIt-Anchor" href="#n-s流程图不常用"></a> N-S流程图（不常用）</h3><p><a href="https://zhuanlan.zhihu.com/p/360921957">N-S图（盒图）详解（附案例）</a></p><h3 id="伪代码"><a class="markdownIt-Anchor" href="#伪代码"></a> 伪代码</h3><p>伪代码利用介于自然语言和计算机语音之间的文字符号来描述算法，每一行或者几行表示一个基本操作，易于阅读，结构紧凑，修改方便，便于向算法程序过渡。因此伪代码用得比流程图要多。</p>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.1. C语言基础 </category>
          
          <category> 2.1.2. C语言基本语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.2.2-C语言中运算符的定义与应用</title>
      <link href="/posts/41825.html"/>
      <url>/posts/41825.html</url>
      
        <content type="html"><![CDATA[<h2 id="c语言算数运算符"><a class="markdownIt-Anchor" href="#c语言算数运算符"></a> C语言算数运算符</h2><table><thead><tr><th>运算符</th><th>名称</th></tr></thead><tbody><tr><td>+</td><td>加法运算符</td></tr><tr><td>-</td><td>减法运算符</td></tr><tr><td>*</td><td>乘法运算符</td></tr><tr><td>/</td><td>除法运算符</td></tr><tr><td>%</td><td>求余运算符</td></tr><tr><td>++</td><td>自增运算符</td></tr><tr><td>–</td><td>自减运算符</td></tr></tbody></table><p>a<ins>和</ins>a的不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a++是先参与运算再自增，++a反之。</span><br></pre></td></tr></table></figure><h2 id="c语言关系运算符"><a class="markdownIt-Anchor" href="#c语言关系运算符"></a> C语言关系运算符</h2><table><thead><tr><th>运算符</th><th>名称</th><th>备注</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td><td></td></tr><tr><td>&lt;</td><td>小于</td><td></td></tr><tr><td>&gt;=</td><td>大于等于</td><td>常见错误：=&gt;</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>常见错误：=&lt;</td></tr><tr><td>==</td><td>等于</td><td></td></tr><tr><td>!=</td><td>不等于</td><td></td></tr></tbody></table><p>特别说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=   表示的是赋值</span><br><span class="line">==  判断功能</span><br></pre></td></tr></table></figure><h3 id="关系运算符的使用"><a class="markdownIt-Anchor" href="#关系运算符的使用"></a> 关系运算符的使用</h3><p>在关系运算中，0为假，其他数字都为真。</p><h4 id="一般情况下配合if语句使用"><a class="markdownIt-Anchor" href="#一般情况下配合if语句使用"></a> 一般情况下配合if语句使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系运算符的表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//语句1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果关系运算符为真  则执行语句1</p><p>关系运算符的表达式成立  -&gt;  运算结果为真    -&gt;  返回1   -&gt;  执行语句1<br />关系运算符的表达式不成立    -&gt;  运算结果为假  -&gt;  返回0 -&gt;  不执行语句1</p><h4 id="有时也在while语句中使用"><a class="markdownIt-Anchor" href="#有时也在while语句中使用"></a> 有时也在while语句中使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(关系运算符表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//语句1；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果关系运算符为真  则执行语句1</p><p>关系运算符表达式成立  -&gt;  运算结果为真  -&gt;  返回1  -&gt;  执行语句1<br />关系运算符表达式不成立  -&gt;  运算结果为假  -&gt;  返回0  -&gt;  不执行语句1</p><h2 id="c语言位运算符"><a class="markdownIt-Anchor" href="#c语言位运算符"></a> C语言位运算符</h2><h3 id="c语言中六种位运算符"><a class="markdownIt-Anchor" href="#c语言中六种位运算符"></a> C语言中六种位运算符</h3><h4 id="按位与0对输出有影响直接置0"><a class="markdownIt-Anchor" href="#按位与0对输出有影响直接置0"></a> ‘&amp;’  按位与（0对输出有影响，直接置0）</h4><p>运算规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a&amp;b = <span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line">a&amp;b = <span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span>;</span><br><span class="line">a&amp;b = <span class="number">1</span> &amp; <span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line">a&amp;b = <span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a &amp; b = <span class="number">0000</span> <span class="number">0110</span> &amp; <span class="number">0000</span> <span class="number">0101</span> = </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">————————</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">即  a &amp; b = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><h4 id="按位或1对输出有影响直接置1"><a class="markdownIt-Anchor" href="#按位或1对输出有影响直接置1"></a> ‘|’    按位或（1对输出有影响，直接置1）</h4><p>运算规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a | b = <span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line">a | b = <span class="number">0</span> | <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line">a | b = <span class="number">1</span> | <span class="number">0</span> = <span class="number">1</span>;</span><br><span class="line">a | b = <span class="number">0</span> | <span class="number">0</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a | b = <span class="number">0000</span> <span class="number">0110</span> | <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0110</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0101</span></span><br><span class="line">——————————</span><br><span class="line"><span class="number">0000</span> <span class="number">0</span> <span class="number">111</span> = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">即  a | b = <span class="number">7</span>;</span><br></pre></td></tr></table></figure><h4 id="按位异或相当于不带进位的二进制加法"><a class="markdownIt-Anchor" href="#按位异或相当于不带进位的二进制加法"></a> ‘^’    按位异或（相当于不带进位的二进制加法）</h4><p>运算规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（a、b不同时为<span class="number">1</span>，相同时为<span class="number">0</span>）</span><br><span class="line">a ^ b = <span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span>;</span><br><span class="line">a ^ b = <span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line">a ^ b = <span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span>;</span><br><span class="line">a ^ b = <span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a ^b = <span class="number">0000</span> <span class="number">0110</span> | <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0110</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0101</span></span><br><span class="line">——————————</span><br><span class="line"><span class="number">0000</span> <span class="number">0011</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">即  a ^b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="~-取反"><a class="markdownIt-Anchor" href="#~-取反"></a> ‘~’    取反</h4><p>规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span>   ~a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">1</span>   ~a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 6 = b0000 0110</span><br><span class="line">~a = 1111 1001 = 249</span><br><span class="line">249  =255 = FF = 1111 1111</span><br></pre></td></tr></table></figure><h4 id="左移"><a class="markdownIt-Anchor" href="#左移"></a> ‘&lt;&lt;’   左移</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line">a = <span class="number">6</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b;</span><br><span class="line">b = a &lt;&lt; <span class="number">1</span>; <span class="comment">//b为a二进制数左移一位，相当于乘以2</span></span><br></pre></td></tr></table></figure><p>b = a &lt;&lt; 1 = 0x0c = 12;</p><h4 id="右移"><a class="markdownIt-Anchor" href="#右移"></a> ‘&gt;&gt;’   右移</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line">a= <span class="number">6</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b;</span><br><span class="line">b = a&gt;&gt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>a = 0000 0110 = 6;<br />由于 0000 0011 = 3;<br />则 b = a&gt;&gt;1 = 3;</p><p>对于b = a&gt;&gt; 2<br />有0000 0001 = 1;</p><p>Ps：无论是左移还是右移，溢出的一位舍去，是否溢出要看变量的类型，因为变量的类型决定着变量有多少位。</p><h3 id="位运算符的运用"><a class="markdownIt-Anchor" href="#位运算符的运用"></a> 位运算符的运用</h3><p>以下代码块利用上面的位运算符达到控制任务顺序的目的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dat = <span class="number">0xAA</span>; <span class="comment">//b1010 1010;</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dat &amp; <span class="number">0x80</span>)    <span class="comment">//(dat)1010 1010   &amp;   b1000 0000(0x80)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第1,3,5,7个循环触发，if内结果为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第2,4,6,8个循环触发，if内结果为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dat &lt;&lt;= <span class="number">1</span>;<span class="comment">//dat左移一位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1010 1010 &lt;&lt; 1<br />得到0101,0100</p><h2 id="c语言逻辑运算符"><a class="markdownIt-Anchor" href="#c语言逻辑运算符"></a> C语言逻辑运算符</h2><h3 id="与运算"><a class="markdownIt-Anchor" href="#与运算"></a> ‘&amp;&amp;’  与运算</h3><p>常见应用场景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span> &amp;&amp; 表达式<span class="number">2</span>  &amp;&amp; 表达式<span class="number">3</span> ...)</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有当表达式1、表达式2、表达式3都为真的时候（都成立时），执行语句1；否则不执行语句1。</p><h3 id="或运算"><a class="markdownIt-Anchor" href="#或运算"></a> ‘||’    或运算</h3><p>常见应用场景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span> || 表达式<span class="number">2</span> || 表达式<span class="number">3</span> ...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 语句1；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当表达式1，表达式2和表达式3至少有1个为真时，执行语句1。</p><h3 id="非运算"><a class="markdownIt-Anchor" href="#非运算"></a> ‘!’ 非运算</h3><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> a;</span><br><span class="line">a = <span class="number">0</span>;  <span class="comment">// !a 为 1</span></span><br><span class="line">a = <span class="number">1</span>;  <span class="comment">// !a 为 0</span></span><br></pre></td></tr></table></figure><p>常见应用场景：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!变量a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 表达式1；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当变量a为0时，!a 为真  执行表达式1</li><li>当变量a非0时，!a 为假  不执行表达式1；</li></ol><h2 id="c语言赋值运算符"><a class="markdownIt-Anchor" href="#c语言赋值运算符"></a> C语言赋值运算符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a += b;     <span class="comment">// 等价于   a = a+b;</span></span><br><span class="line">a -= b;     <span class="comment">// 等价于   a = a-b;</span></span><br><span class="line">a *= b;     <span class="comment">// 等价于   a = a*b;</span></span><br><span class="line">a /= b;     <span class="comment">// 等价于   a = a/b;</span></span><br><span class="line">a %= b;     <span class="comment">// 等价于   a = a%b;</span></span><br><span class="line">a &lt;&lt;= <span class="number">1</span>;    <span class="comment">// 等价于   a = a&lt;&lt;1;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><a href="http://c.biancheng.net/view/258.html"><strong>赋值运算符及赋值表达式，C语言赋值运算符及其赋值表达式详解</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.1. C语言基础 </category>
          
          <category> 2.1.2. C语言基本语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.2.1-C语言中变量的定义与应用</title>
      <link href="/posts/32138.html"/>
      <url>/posts/32138.html</url>
      
        <content type="html"><![CDATA[<h2 id="变量的概念"><a class="markdownIt-Anchor" href="#变量的概念"></a> 变量的概念</h2><p>变量(官方定义)：是用来存储单片机/计算机系统中 计算的过程或结果数值的一个抽象概念<br />变量：就是一种在程序执行过程中其值不断变化的量。<br />常量：就是其定义之后数值不会变化的量</p><h2 id="变量的数据类型"><a class="markdownIt-Anchor" href="#变量的数据类型"></a> 变量的数据类型</h2><p><img src="https://oss.magicconch.top/api/raw/?path=/img/2.1.2.1/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB.webp" alt="数据类型汇总" /></p><table><thead><tr><th>类型</th><th>适用范围</th><th>定义方法</th></tr></thead><tbody><tr><td>布尔型</td><td>（bool）1-真 0-假</td><td>常用bit ,用bool和bit都能定义。</td></tr><tr><td>字符型</td><td>1byte，8个bit</td><td>char</td></tr><tr><td>整数型</td><td>整数型与字符型存储的数据长度不一样</td><td>int、short、long</td></tr><tr><td>浮点型</td><td>小数</td><td>float、double</td></tr></tbody></table><p>不同单片机中不同的数据类型所对应的位数也有所不同。<br />在stm32中，short为16bit，int和long为32bit。<br />对于有符号的数据类型，最高位表示正负，1为负，0为正。</p><p>单片机变量定义及其范围：</p><table><thead><tr><th>数据类型</th><th>关键字</th><th>所占位数</th><th>表示数的范围</th></tr></thead><tbody><tr><td>无符号字符型</td><td>unsigned char</td><td>8</td><td>0 ~ 255</td></tr><tr><td>有符号字符型</td><td>char</td><td>8</td><td>-128 ~ 127</td></tr><tr><td>无符号整型</td><td>unsigned int</td><td>16</td><td>0 ~ 65535</td></tr><tr><td>有符号整型</td><td>int</td><td>16</td><td>-32768 ~ 32767</td></tr><tr><td>无符号长整型</td><td>unsigned long</td><td>32</td><td>0 ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup></mrow><annotation encoding="application/x-tex">2^{32}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>-1</td></tr><tr><td>有符号长整型</td><td>long</td><td>32</td><td>-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ~ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>-1</td></tr><tr><td>单精度实型</td><td>float</td><td>32</td><td>3.4e-38 ~ 3.4e38</td></tr><tr><td>双精度实型</td><td>double</td><td>64</td><td>1.7e-308 ~ 1.7e308</td></tr><tr><td>位类型</td><td>bit</td><td>1</td><td>0 ~ 1</td></tr></tbody></table><h2 id="定义变量的规则"><a class="markdownIt-Anchor" href="#定义变量的规则"></a> 定义变量的规则</h2><p>1、变量是由 <strong>英文字母（大小写）、数字、下划线</strong> 组成；<br />2、变量名以 <strong>英文字母或下划线</strong> 开头；<br />3、变量名中的字母是区分大小写的；<br />4、变量名不能是关键字；<br />5、变量名中不能包含空格、标点符号和类型说明符（可包含下划线）。</p><p>C语言中的关键字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto、break、case、char、const、continue、default、do、double、else、enum、extern、float、for、goto、if、int、long、register等等</span><br></pre></td></tr></table></figure><p>全局变量和局部变量的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">全局变量：在函数外</span><br><span class="line">局部变量：在函数内</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.1. C语言基础 </category>
          
          <category> 2.1.2. C语言基本语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.1.1-单片机基本理解</title>
      <link href="/posts/45612.html"/>
      <url>/posts/45612.html</url>
      
        <content type="html"><![CDATA[<p>很长一段时间以来在word上记了一些笔记，但却一直没能回头复习。再三斟酌，决定将笔记以博客的形式写出来，并借此机会对所学内容进行一次复习，我想应该不用太多时间就能搬运完。</p><p>C语言基础将从单片机开始写，直接学习C语言未免过于乏味，但如果通过C语言在单片机上的应用来间接学习C语言，就能让理论与实际充分结合，达到事半功倍的效果。</p><h2 id="单片机可以做什么"><a class="markdownIt-Anchor" href="#单片机可以做什么"></a> 单片机可以做什么</h2><p>单片机：CPU、存储器、IO接口、定时器集成到一个硅片上，具有小而完整的微型计算机系统。<br />单片机使用灵活，经过二次硬件和软件开发，实现不同功能，满足不同需求。<br />硬件工程师：根据单片机资源设计硬件电路、原理图设计、PCB绘制、硬件功能调试。<br />软件工程师：单片机C语言基础、程序开发环境、程序的烧录、软件功能调试与测试。</p><h2 id="单片机资源有哪些"><a class="markdownIt-Anchor" href="#单片机资源有哪些"></a> 单片机资源有哪些</h2><p>STC15W104接口资源介绍：</p><table><thead><tr><th>名称</th><th>资源数量或大小</th><th>资源作用</th></tr></thead><tbody><tr><td>工作电压</td><td>2.4-5.5V</td><td></td></tr><tr><td>程序空间（FLASH ROM）</td><td>4K=4096bytes</td><td>用于存储单片机代码(code)</td></tr><tr><td>SRAM</td><td>128bytes</td><td>用来存储单片机代码中的变量（变量的定义不能大于128字节）</td></tr><tr><td>EEPROM</td><td>1K</td><td>具有掉电保存功能</td></tr><tr><td>IO</td><td>6个，P3.0-P3.5</td><td>单片机的输入输出端口。对于AT89C52芯片，P0.0-P0.7、P1.0-P1.7、P2、P3</td></tr><tr><td>定时器</td><td>2个</td><td>精准定时。电子时钟-&gt;定时器。</td></tr><tr><td>串口</td><td></td><td>串口是单片机与外部设备通讯的重要接口。芯片与芯片之间通讯。例WIFI/蓝牙/4G</td></tr><tr><td>ADC</td><td></td><td>稍高端的单片机集成。模拟的实际电压转成数字信号。普通IO接口只识别高低电平，有ADC的IO可识别模拟电压。</td></tr><tr><td>DAC</td><td></td><td>通过端口输出一个模拟电压。普通IO只输出高低电平，DAC可输出一个模拟电压（0-VCC）的一个任意电压。</td></tr><tr><td>SPI/IIC（串行协议）</td><td></td><td>都是标准通讯接口。一般用于实现芯片之间通讯。<a href="https://blog.csdn.net/chenpuo/article/details/81023882"><strong>I2C和SPI总线对比</strong></a></td></tr><tr><td>看门狗</td><td></td><td>用来防止代码程序死机与非正常运行。</td></tr></tbody></table><h2 id="进制的介绍与转换"><a class="markdownIt-Anchor" href="#进制的介绍与转换"></a> 进制的介绍与转换</h2><p>最小储存单元为bit（比特），存0和1<br />8个储存元组成1Byte（字节）</p><p>二进制：单片机单个IO的配置，使用少，一般用16进制表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示方法：b00100011</span><br></pre></td></tr></table></figure><p>十进制：一般使用于单片机算术计算，逻辑计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示方法：35</span><br></pre></td></tr></table></figure><p>十六进制：寄存器配置、运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示方法：0x23</span><br></pre></td></tr></table></figure><h2 id="c51点亮第一个led灯"><a class="markdownIt-Anchor" href="#c51点亮第一个led灯"></a> C51点亮第一个LED灯</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">任务: 点亮无线门磁探测器的LED1 LED2 </span><br><span class="line">准备：无线门磁探测器、烧录器、数字电源一台、电脑1台（安装KEIL C51）</span><br><span class="line">原理：C语言源程序-&gt;C编译器-&gt;汇编代码-&gt;汇编器-&gt;机器代码(.hex  .bin)</span><br></pre></td></tr></table></figure><p>点亮LED灯有以下步骤</p><blockquote><blockquote><p>STC15W104 工程新建<br />STC15W104 生成烧录文件<br />HEX为单片机可识别的文件</p></blockquote><blockquote><p>STC15W104 单片机烧录方法<br />冷启动烧录：先下载程序再供电<br />热启动烧录：供电情况下烧录程序</p></blockquote><blockquote><p>点亮LED灯</p></blockquote></blockquote><p>单片机的高低电平：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低电平：GND    # 低压0V</span><br><span class="line">高电平：VCC    # 单片机的供电电压</span><br></pre></td></tr></table></figure><p>单片机的普通IO口只能输出高电平或者低电平：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IO=0 则单片机的IO口输出低电平   0V</span><br><span class="line">IO=1 则单片机的IO口输出高电平   VCC</span><br></pre></td></tr></table></figure><p>具体操作步骤：</p><ol><li>安装烧录接口驱动</li><li>在STC-ISP的“keil仿真设置”中点击“添加型号和头文件到keil中”，选择keil_C51所在文件夹</li><li>在keil中新建new project，设置项目文件夹与项目文件名，选择项目用到的芯片，建立项目</li><li>创建主函数文件main.c，并将之加入到project中，再继续编写main.c文件，添加头文件，将头文件修改成使用的型号，型号在keil目录中的INC文件夹中可以找到。</li><li>编写好主函数之后，点击option for taget，选择output选项卡，点击编译，生成HEX文件。</li><li>然后回到STC-ISP中，选择芯片，选择烧录器的串口，选择工作晶振频率5.5296Mhz，导入程序文件，连接烧录器和无线门磁探测器，再冷启动烧录。</li></ol><p>关于延时函数：<em>nop</em>()函数存在于头文件#include &quot;intrins.h&quot;中，表示一个机械周期，一个机械周期包含12个时钟周期，一个时钟周期的时长为晶振频率的倒数。1个机械周期 = 12个时钟周期 = 12 * (1/f)。（f 为晶振频率）</p>]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.1. C语言基础 </category>
          
          <category> 2.1.1. 了解单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.4-为Melody主题的HEXO博客添加gitalk评论区</title>
      <link href="/posts/54282.html"/>
      <url>/posts/54282.html</url>
      
        <content type="html"><![CDATA[<hr /><p>2023.9.1 更新：不如直接利用github discussion部署Giscus，效果更好还更方便</p><hr /><p>担心博客有错误无法及时改正，所以在博客中加入评论区，gitalk评论区模块好处非常多，首先当然是免费，其次必须登录GitHub账号才能评论，有一定防灌水的作用。本人使用的HEXO主题是<a href="https://github.com/Molunerfinn/hexo-theme-melody"><strong>hexo-theme-melody</strong></a>，这个主题自带功能比较多，界面也比较简洁，也集成了gitalk模块，用户只需要注册应用并编辑配置文件即可加入gitalk模块</p><h2 id="创建存放评论的仓库"><a class="markdownIt-Anchor" href="#创建存放评论的仓库"></a> 创建存放评论的仓库</h2><p>gitalk的原理是将博客中的评论存放在github仓库的issues中。<br />最好不要用自己的主页仓库(<a href="http://xn--xxx-4l3e.github.io">即xxx.github.io</a>)作为存放评论的仓库，后续可能会出现一些问题，所以专门创建一个public仓库来存放评论。</p><p><img src="https://oss.magicconch.top/api/raw/?path=/img/1.4/create-github-public-repo.png" alt="create-github-public-repo.png" /></p><h2 id="创建github-oauth-application"><a class="markdownIt-Anchor" href="#创建github-oauth-application"></a> 创建github OAuth application</h2><p><a href="https://github.com/settings/applications/new">应用快捷注册地址</a></p><p>按照下图中填写<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/1.4/register-github-OAuth-app.png" alt="register-github-OAuth-app.png" /></p><p>点击绿色的注册按钮，在新页面中点击&quot;Generate a new client secret&quot;，生成客户端密码，然后记录下&quot;Client ID&quot;和&quot;Client secrets&quot;，等会儿要填到hexo-theme-melody的配置文件&quot;_config.melody.yml&quot;中</p><h2 id="编辑_configmelodyyml并部署"><a class="markdownIt-Anchor" href="#编辑_configmelodyyml并部署"></a> 编辑&quot;_config.melody.yml&quot;并部署</h2><p>按照下图编辑好配置文件<br /><img src="https://oss.magicconch.top/api/raw/?path=/img/1.4/gitalk_config.melody.yml.png" alt="gitalk_config.melody.yml.png" /></p><p>然后就是喜闻乐见的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>部署成功！</p>]]></content>
      
      
      <categories>
          
          <category> 1. HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3-为HEXO博客添加类别和标签</title>
      <link href="/posts/16283.html"/>
      <url>/posts/16283.html</url>
      
        <content type="html"><![CDATA[<h2 id="blog添加分类categories和标签tags-文章内容来源"><a class="markdownIt-Anchor" href="#blog添加分类categories和标签tags-文章内容来源"></a> Blog添加分类(categories)和标签(tags) <a href="https://zhuanlan.zhihu.com/p/50787870"><strong>文章内容来源</strong></a></h2><h3 id="创建分类选项"><a class="markdownIt-Anchor" href="#创建分类选项"></a> 创建“分类”选项</h3><h4 id="生成分类页并添加tpye属性"><a class="markdownIt-Anchor" href="#生成分类页并添加tpye属性"></a> 生成“分类”页并添加tpye属性</h4><p>打开命令行，进入博客所在文件夹。执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure><p>成功后会提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/categories/index.md</span><br></pre></td></tr></table></figure><p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-10-31 13:47:40</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>添加type: &quot;categories&quot;到内容中，添加后是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-10-31 13:47:40</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><h4 id="给文章添加categories属性"><a class="markdownIt-Anchor" href="#给文章添加categories属性"></a> 给文章添加“categories”属性</h4><p>打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo博客+Github博客教程：03添加分类，标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-11-01 14:17:46</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p><h3 id="创建标签选项"><a class="markdownIt-Anchor" href="#创建标签选项"></a> 创建“标签”选项</h3><h4 id="生成标签页并添加tpye属性"><a class="markdownIt-Anchor" href="#生成标签页并添加tpye属性"></a> 生成“标签”页并添加tpye属性</h4><p>打开命令行，进入博客所在文件夹。执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure><p>成功后会提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/tags/index.md</span><br></pre></td></tr></table></figure><p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-10-31 13:47:40</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>添加type: &quot;tags&quot;到内容中，添加后是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-10-31 13:47:40</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><h4 id="给文章添加tags属性"><a class="markdownIt-Anchor" href="#给文章添加tags属性"></a> 给文章添加“tags”属性</h4><p>打开需要添加标签的文章，为其添加tags属性。<br />下方的tags:下方的- jQuery - 表格 - 表单验证<br />就是这篇文章的标签</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo博客+Github博客教程：03添加分类，标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-11-01 14:17:46</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">基础知识</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">github</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">博客</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。</p><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>由此可见，目录和标签的设置思路几乎一模一样。<br />scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。我们可以打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，之后执行&quot;hexo new 文章名&quot;命令生成的文件，.md文件顶部就有&quot;categories:&quot;项（当然我个人更倾向于直接在/sourse/_posts中创建文件，这样似乎更加方便）。</p>]]></content>
      
      
      <categories>
          
          <category> 1. HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.2-HEXO常用命令</title>
      <link href="/posts/17404.html"/>
      <url>/posts/17404.html</url>
      
        <content type="html"><![CDATA[<h2 id="bash命令"><a class="markdownIt-Anchor" href="#bash命令"></a> bash命令</h2><table><thead><tr><th>命令</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>hexo serve</td><td>在本机4000端口上运行博客web服务</td><td>测试用</td></tr><tr><td>hexo clean</td><td>清除本地缓存</td><td>推送到远程仓库前清理缓存</td></tr><tr><td>hexo g</td><td>生成本地静态网页</td><td></td></tr><tr><td>hexo algolia</td><td>调用api生成 algolia 索引</td><td></td></tr><tr><td>hexo d</td><td>推送更改到远程地址</td><td></td></tr><tr><td>hexo new page categories</td><td>创建新类别</td><td>每篇文章只能处于一个类别中或者一个类别的子类别中</td></tr><tr><td>hexo new page tags</td><td>创建新标签</td><td>每篇文章可以有多个标签</td></tr></tbody></table><h2 id="插件"><a class="markdownIt-Anchor" href="#插件"></a> 插件</h2><p>生成站点地图：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>站点地图位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://blog.magicconch.top/sitemap.xml</span><br><span class="line">https://blog.magicconch.top/baidusitemap.xml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 1. HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1-hello-world</title>
      <link href="/posts/816.html"/>
      <url>/posts/816.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 1. HEXO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1.3.4-队列算法及产品应用</title>
      <link href="/posts/ae477bcf.html"/>
      <url>/posts/ae477bcf.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 2. 嵌入式 </category>
          
          <category> 2.1. C语言基础 </category>
          
          <category> 2.1.3. 程序架构内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 程序架构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
